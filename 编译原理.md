## 引论

+ 编译器和解释器的区别？
  + 编译器就是将某一种语言翻译成另一种语言。
  + 解释器是直接利用用户提供的输入执行源程序中指定的操作。
  + 编译型的语言的执行的速度要快于解释型的语言，但是解释型的语言的错误诊断效果比编译型的语言更好。
  
+ 编译的过程中的一些处理器（这些都不是实际的物理机器，而是一些程序）
  + 预处理器
    + 预处理器先将程序分割成多个模块，并存放于独立的文件中，把源程序聚合在一起的任务有这个完成。同时还负责将宏转换成源语言的语句。
  + 汇编器
    + 经过预处理的源程序作为输入传递给一个编译器。编译器可能产生一个汇编语言程序作为输出，这个时候由汇编器处理这些汇编程序。并生成可以重新定位的机器代码。
  + 链接器
    + 大型程序通过被分为多个部分进行编译。可以重新定位的机器代码有必要和其他可重定位的目标文件以及库文件连接到一起，但是一个文件中的带按摩可能执行另一个文件中的位置，这个时候就需要使用链接解决外部内存地址的问题。
  + 加载器
    + 把所有的可执行目标文件放到内存中执行。
  
+ 编译器的结构
  + 词法分析
    + 词法分析器读入组成源程序的字节流，然后将他们组成一个有意义的词素的序列。
  + 语法分析
    + 语法分析器是将词法分析器的各个词法单元用来创建树形的中间表示。该中间表示给出了词法产生的单元流的语法结构。从而形成了了一棵语法树。
  + 语义分析
    + 使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。在这个部分做的有类型检查。
  + 中间代码生成
    + 中间代码生成应该具有两个重要的性质，一个是易于生成，另一个是能轻松翻译目标机器上面的语言。
  + 代码优化
    + 这一部分就是改进优化中间代码，生成更好的目标代码。
  + 目标代码生成
    + 我们得到源程序的中间表示形式作为输入，然后映射到目标语言，对于目标语言是机器语言的代码，需要为程序的每个变量合理地分配内存位置，然后，中间指令被翻译成了机器指令序列。
  + 符号表管理
    + 符号表记录了源程序总使用的变量的名字，以及这些名字的各种属性的有关信息。这种数据结构可以使得编译器迅速查找到每个名字的记录。
  + 上下文无关法
    + 一共包含四个部分：开始符号，终结符号，非终结符号和产生式
    + 最左推导和最右推导的区别就是替换的顺序不同。
  
  ## 语法分析
  
  + 文法定义
    + 一个上下文无关文法由四个元素组成，一个终结符号集合，一个非终结符号集合，一个产生式集合，指定一个非终结符号的开始字符。
  + 语法分析的任务是接受一个终结符号串作为输入，找出文法的开始字符推导出这个串的方法。如果我们不能从文法的开始字符推导到该终结字符，则报告该符号串文法包含语法错误。
  + 语法分析树
    + 根节点的标号为文法的开始字符。
    + 每个叶子结点的标号为一个终结字符。
    + 每个内部结点的标号为一个非终结符号。
    + 如果非终结符号A是某一个内部结点的标号，并且它的子节点的标号是从左到右分别为$X_1,X_2,X_3...X_n$,那么它的子节点既可以是终结结点，也可以是非终结结点，那么这个是一中特殊的情况。
  + 二义性
    + 一个文法可能存在多棵语法分析树，能够生成同一个给定的终结字符串。这样的文法具有二义性。如果想要证明一个文法具有二义性，我们只需要找到一个终结符号串，说明它是两颗以上的语法分析树的结果。
  
  ## 词法分析
  
  + 词法分析器的功能就是输入源程序，输出单词符号。单词符号分为五种：关键字，标识符，常数，运算符和界符。

### 编译原理第二章

+ 给出一个文法，证明这个文法有二义性。我们可以通过找到一个句型。利用给出的文法构造这个句型的二叉树。如果可以构造出两棵不一样的树，那么说明这个文法有二义性。
+ 句型
  + 0型文法，0型文法也叫短语文法，相当于图灵机。
  + 1型文法，也叫做上下文有关文法。对非终结符进行替换的时候需要考虑上下文。
  + 2型文法，也叫做上下文无关文法。
  + 3型文法，左右线性文法的区分就是看输入的符号在状态的左边还是右边，如果如果产生式的右边的状态在右边，就是右线性文法，否则就是左线性文法。

### 编译原理第四章

+ 消除文法的左递归

+ 如何求First集合

  + $若x\in{V_T},则First(x)={x}$

  + $若X\in{V_N},且有X->a...,则把a加入到First(x)集合里面$

  + $$
    如果X->Y...，同时Y\in{V_N},则把First(Y)加入到First(X)里面.如果有X->Y_1Y_2...Y_i \\
    对于1<=j<=i-1,有{\epsilon}\in{First(Y)}，那么就把First(Y_i)中的所有的元素都加入到First(x)里面 \\
    特殊的，如果对于所有的Y_i,{\epsilon}\in{First(Y_i)},那么就把{\epsilon}加入到First(x)里面
    $$

+ 如何求Follow集合
  + $对于文法的开始符号，首先将\#加入到Follow集合里面$
  + $若A->aBb是一个产生式，那么就把First(b)加入到Follow(B)里面$
  + $若A->aB是一个产生式，或者A->aBb是一个产生式，而{\epsilon}\in{First(b)}，则把Follow(A)加入到Follow(B)里面$

+ 如何构建一个预测分析表
  + $对于每个文法G的产生式A->{\alpha}执行第二步和第三步操作$
  + $对于每个终结符a\in{First(\alpha)}，则把A->\alpha加到[A,a]里面$
  + $若\epsilon\in{First(\alpha)},那么对于任何的b\in{Follow(A)},则把A->a加入到[A,b]里面$
  + $把所有没有定义的M[A,a]都表上错误标识$

+ 什么是LL(1)文法
  + 文法中不包含左递归
  + 对于文法中的每个非终结符A的各个产生式的候选首符集两两不相交。候选首符集就是候选式的第一个符号的First集合不相交。
  + 文法中的每个非终结符A，若它存在某一个候选首符集包含$\epsilon$,那么需要这个非终结符的First集合和Follow集合相交为空。

### 编译原理第五章

+ 进行移进-归约操作。
+ 一个句型的最左直接短语称为该句型的句柄。
+ 如何判断直接短语，最左素短语？
  + 我们根据给定的文法，给这个句型构造出一棵树。
  + 根据这棵树，当子树不包含其他更小的子树的时候，该子树叶子结点所组成的字符串就是该句型的直接短语。
  + 句柄就是处在最左边的直接短语。

+ 如何求$FirstVT$集合
  + $对于每个给定的文法，我们需要找P->a...或者是P->Qa...这种形式的，如果满足这种形势的，我们就把a加入到FirstVT(P)里面$
  + $对于给定的文法，如果存在P->Q...,那么就把FirstVT(Q)里面的元素都加入到FirstVT(P)里面去$
+ 如何求$LastVT$集合
  + $对于给定的文法，我们需要找到P->...Q或者是P->...aQ这种形式的，如果满足这种形式的，那么我们就把a加入到LastVT(P)里面$
  + $对于给定的文法，如果存在P->...Q,那么就把LastVT(Q)的元素都加入到LastVT(P)里面$

+ 如何构造预测分析表(这个是和终结符有关的)
  + $对于每个文法，我们进行如下处理：如果对于P->{X_1}{X_2}{X_3}_...{X_i}X_{i+1}...X_n$
  + $如果有{X_i}{X_{i+1}}都是终结符，也就是ab形式的，那么我们就置X_i==X_{i+1}$
  + $如果有aQb这种形式的，那么a==b$
  + $如果有aQ这种形式的，那么对于First VT(Q)里面的每个元素x，都有a<x$
  + $如果有Qa这种形式的，那么对于LastVT(Q)里面的每个元素x，都有x>a$

+ 
