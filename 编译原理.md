## 引论

+ 编译器和解释器的区别？
  + 编译器就是将某一种语言翻译成另一种语言。
  + 解释器是直接利用用户提供的输入执行源程序中指定的操作。
  + 编译型的语言的执行的速度要快于解释型的语言，但是解释型的语言的错误诊断效果比编译型的语言更好。
  
+ 编译的过程中的一些处理器（这些都不是实际的物理机器，而是一些程序）
  + 预处理器
    + 预处理器先将程序分割成多个模块，并存放于独立的文件中，把源程序聚合在一起的任务有这个完成。同时还负责将宏转换成源语言的语句。
  + 汇编器
    + 经过预处理的源程序作为输入传递给一个编译器。编译器可能产生一个汇编语言程序作为输出，这个时候由汇编器处理这些汇编程序。并生成可以重新定位的机器代码。
  + 链接器
    + 大型程序通过被分为多个部分进行编译。可以重新定位的机器代码有必要和其他可重定位的目标文件以及库文件连接到一起，但是一个文件中的带按摩可能执行另一个文件中的位置，这个时候就需要使用链接解决外部内存地址的问题。
  + 加载器
    + 把所有的可执行目标文件放到内存中执行。
  
+ 编译器的结构
  + 词法分析
    + 词法分析器读入组成源程序的字节流，然后将他们组成一个有意义的词素的序列。
  + 语法分析
    + 语法分析器是将词法分析器的各个词法单元用来创建树形的中间表示。该中间表示给出了词法产生的单元流的语法结构。从而形成了了一棵语法树。
  + 语义分析
    + 使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。在这个部分做的有类型检查。
  + 中间代码生成
    + 中间代码生成应该具有两个重要的性质，一个是易于生成，另一个是能轻松翻译目标机器上面的语言。
  + 代码优化
    + 这一部分就是改进优化中间代码，生成更好的目标代码。
  + 目标代码生成
    + 我们得到源程序的中间表示形式作为输入，然后映射到目标语言，对于目标语言是机器语言的代码，需要为程序的每个变量合理地分配内存位置，然后，中间指令被翻译成了机器指令序列。
  + 符号表管理
    + 符号表记录了源程序总使用的变量的名字，以及这些名字的各种属性的有关信息。这种数据结构可以使得编译器迅速查找到每个名字的记录。
  + 上下文无关法
    + 一共包含四个部分：开始符号，终结符号，非终结符号和产生式
    + 最左推导和最右推导的区别就是替换的顺序不同。
  
  ## 语法分析
  
  + 文法定义
    + 一个上下文无关文法由四个元素组成，一个终结符号集合，一个非终结符号集合，一个产生式集合，指定一个非终结符号的开始字符。
  + 语法分析的任务是接受一个终结符号串作为输入，找出文法的开始字符推导出这个串的方法。如果我们不能从文法的开始字符推导到该终结字符，则报告该符号串文法包含语法错误。
  + 语法分析树
    + 根节点的标号为文法的开始字符。
    + 每个叶子结点的标号为一个终结字符。
    + 每个内部结点的标号为一个非终结符号。
    + 如果非终结符号A是某一个内部结点的标号，并且它的子节点的标号是从左到右分别为$X_1,X_2,X_3...X_n$,那么它的子节点既可以是终结结点，也可以是非终结结点，那么这个是一中特殊的情况。
  + 二义性
    + 一个文法可能存在多棵语法分析树，能够生成同一个给定的终结字符串。这样的文法具有二义性。如果想要证明一个文法具有二义性，我们只需要找到一个终结符号串，说明它是两颗以上的语法分析树的结果。
  
  ## 词法分析
  
  + 词法分析器的功能就是输入源程序，输出单词符号。单词符号分为五种：关键字，标识符，常数，运算符和界符。

### 编译原理第二章

+ 给出一个文法，证明这个文法有二义性。我们可以通过找到一个句型。利用给出的文法构造这个句型的二叉树。如果可以构造出两棵不一样的树，那么说明这个文法有二义性。
+ 句型
  + 0型文法，0型文法也叫短语文法，相当于图灵机。
  + 1型文法，也叫做上下文有关文法。对非终结符进行替换的时候需要考虑上下文。
  + 2型文法，也叫做上下文无关文法。
  + 3型文法，左右线性文法的区分就是看输入的符号在状态的左边还是右边，如果如果产生式的右边的状态在右边，就是右线性文法，否则就是左线性文法。

### 编译原理第四章

+ 消除文法的左递归

+ 如何求First集合

  + $若x\in{V_T},则First(x)={x}$

  + $若X\in{V_N},且有X->a...,则把a加入到First(x)集合里面$

  + $$
    如果X->Y...，同时Y\in{V_N},则把First(Y)加入到First(X)里面.如果有X->Y_1Y_2...Y_i \\
    对于1<=j<=i-1,有{\epsilon}\in{First(Y)}，那么就把First(Y_i)中的所有的元素都加入到First(x)里面 \\
    特殊的，如果对于所有的Y_i,{\epsilon}\in{First(Y_i)},那么就把{\epsilon}加入到First(x)里面
    $$

+ 如何求Follow集合
  + $对于文法的开始符号，首先将\#加入到Follow集合里面$
  + $若A->aBb是一个产生式，那么就把First(b)加入到Follow(B)里面$
  + $若A->aB是一个产生式，或者A->aBb是一个产生式，而{\epsilon}\in{First(b)}，则把Follow(A)加入到Follow(B)里面$

+ 如何构建一个预测分析表
  + $对于每个文法G的产生式A->{\alpha}执行第二步和第三步操作$
  + $对于每个终结符a\in{First(\alpha)}，则把A->\alpha加到[A,a]里面$
  + $若\epsilon\in{First(\alpha)},那么对于任何的b\in{Follow(A)},则把A->a加入到[A,b]里面$
  + $把所有没有定义的M[A,a]都表上错误标识$

+ 什么是LL(1)文法
  + 文法中不包含左递归
  + 对于文法中的每个非终结符A的各个产生式的候选首符集两两不相交。候选首符集就是候选式的第一个符号的First集合不相交。
  + 文法中的每个非终结符A，若它存在某一个候选首符集包含$\epsilon$,那么需要这个非终结符的First集合和Follow集合相交为空。

### 编译原理第五章

+ 进行移进-归约操作。

+ 一个句型的最左直接短语称为该句型的句柄。

+ 如何判断直接短语，最左素短语？
  + 我们根据给定的文法，给这个句型构造出一棵树。
  + 根据这棵树，当子树不包含其他更小的子树的时候，该子树叶子结点所组成的字符串就是该句型的直接短语。
  + 句柄就是处在最左边的直接短语。

+ 如何求$FirstVT$集合
  + $对于每个给定的文法，我们需要找P->a...或者是P->Qa...这种形式的，如果满足这种形势的，我们就把a加入到FirstVT(P)里面$
  + $对于给定的文法，如果存在P->Q...,那么就把FirstVT(Q)里面的元素都加入到FirstVT(P)里面去$
  
+ 如何求$LastVT$集合
  + $对于给定的文法，我们需要找到P->...Q或者是P->...aQ这种形式的，如果满足这种形式的，那么我们就把a加入到LastVT(P)里面$
  + $对于给定的文法，如果存在P->...Q,那么就把LastVT(Q)的元素都加入到LastVT(P)里面$

+ 如何构造预测分析表(这个是和终结符有关的)
  + $对于每个文法，我们进行如下处理：如果对于P->{X_1}{X_2}{X_3}_...{X_i}X_{i+1}...X_n$
  + $如果有{X_i}{X_{i+1}}都是终结符，也就是ab形式的，那么我们就置X_i==X_{i+1}$
  + $如果有aQb这种形式的，那么a==b$
  + $如果有aQ这种形式的，那么对于First VT(Q)里面的每个元素x，都有a<x$
  + $如果有Qa这种形式的，那么对于LastVT(Q)里面的每个元素x，都有x>a$

+ 如何根据文法构造出活前缀

  + 首先，我们先要给出构造出所有文法的项目，就是在符号的左右边加上点。这里我们需要新增一个没有出现的字符，将文法G(S)拓广为G'(S')。S’作为G‘的开始符号。同时，我们需要对每个文法进行编号处理，这是为了后续方便构造出ACTION表的归约部分。
  + 然后，我们做出如下规定
    + $点在最右边的称为归约项目，A->\alpha. 特殊的，如果是开始符号的归约项目，我们称为接受项目,如S'->\alpha.。$
    + $A->\alpha.a\beta，这个a是终结符，这个就叫做移进项目$
    + $A->\alpha.B\beta,这个B是非终结符，那么就叫做待约项目$
  + 构造识别文法所有活前缀的$NFA$
    + $如果状态i为X->{A_1}{A_2}..{A_{i-1}}.{A_{i}}{A_{i+1}}...A_n,同时j状态有X->{A_i}{A_2}...{A_{i}}.{A_{i+1}}...A_n,那么就从状态i连接1条标记为X_i的有向边到状态j$
    + $如果状态i为X->\alpha.A\beta,A是非终结符，那么就连接一条边为\epsilon到所有的状态A->.\gamma$

  + 构造活前缀的$DFA$

    + $如果状态i为X->\alpha.A\beta,A是非终结符，那么就把\epsilon到所有的状态A->.\gamma的这些状态合并成一个项目集$

    + $$
      合并完之后，对于项目及里面的每个项目，我们需要按照如果状态i为X->{A_1}{A_2}..{A_{i-1}}.{A_{i}}{A_{i+1}}...A_n \\同时j状态有X->{A_i}{A_2}...{A_{i}}.{A_{i+1}}...A_n,那么就从状态i连接1条标记为X_i的有向边到状态j
      $$

+ 如何构造ACTION表和GOTO表

  + $这个表格的行就是我们构造出的DFA的状态集的数目，列就是我们的终结符(包括空)和非终结符的数目$

  + $当我们构造出活前缀的DFA的时候，我们需要将根据DFA先完善ACTION表格的移进部分和GOTO表格部分$

  + $$
    对于归约部分，我们需要处理的是，根据DFA的归约项目，我们根据一开始的编号， \\
    观察哪个文法可以得到这个DFA里面的状态,比如如果第一个状态E->*A可以得到， \\
    它的编号是1，那么这一行的状态的所有终结符对应的ACTION部分填上r1
    $$

+ 最后，我们根据ACTION和GOTO表就可以用来判断这个文法是否是一个LR文法

+ 如何判断是否有移进-归约冲突。
  + 某一个产生式的右部是另一个产生式的前缀。
  + $U->X.aY和V->X.$就存在这种冲突，我们发现对于右边的部分，第二个产生式是第一个产生式的前缀。这样的话我们就不知道此时我们需要执行哪种操作，所以有矛盾。
  + 冲突产生的条件
    + 两个产生式出现在自动机中的同一个状态。
    + $FOLLOW(V)和{a}交集为空$

+ 如何判断是否有归约-归约冲突
  + 不同的产生式有相同的右部或者是产生式的右部是另一个产生式的后缀。
  + $U->X. 和 V->X. 或者是 U->XY. 和 V->Y.$
  + 冲突产生的条件
    + 两个产生式出现在自动机的同一个状态。
    + $FOLLOW(U)和FOLLOW(V)的交集不是空$

+ LR(0)算法的局限性。这种算法不能解决移进-归约和归约-归约冲突。
+ SLR文法不存在归约-归约冲突，有可能存在移进-归约冲突，但是通过使用Follow集合我们可以处理出现的移进-归约冲突。

### 编译原理第六章
+ 综合属性和继承属性。综合属性就是可以自下而上传递信息，继承属性就是用于自上而下传递信息。继承属性一般是出现在产生式的右边，综合属性一般是出现在产生式的左边。
+ 非终结符既可以有继承属性，也可以有综合属性。终结符只有综合属性。
### 编译原理第七章
+ 中间语言的几种形式
	+ 后缀式： 把运算量写在前面，把算符写在后面
	+ 图表示法：也就是一个有向无环图。一个内部结点表示的是一个操作符，它的孩子代表的是操作数。
	+ 三地址代码：分为四元式和三元式。
		+ 四元式分为$op,arg1,arg2,result$四个部分
		+ 三元式分为$op,arg1,arg2$三个部分,间接三元式是通过先构造一个三元式表，然后写出间接码表即可。

