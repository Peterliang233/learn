### 基础知识

+ 现代计算机的五大部分：运算器，控制器，主存储器，输入设备和输出设备
+ 高级语言->汇编语言->机器语言
+ 编译程序：将高级语言编写的源程序全部语句执行一次全部翻译成机器语言程序，而后再执行机器语言程序（只需要翻译一次)
+ 解释程序：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译一句（每次执行都要进行翻译）
+ 存储器
  + MAR，位数反映存储单元的个数
  + MDR，位数等于存储字长，也就是每个存储单元的大小
+ 在描述文件的存储大小的时候，1K=2^10,1M=2^20,1G=2^30,1T=2^40，在描述频率，速率的时候，1k=10^3,1M=10^6,1G=10^9,1T=10^12
+ CPU的性能指标
  + cpu主频，cpu内数字脉冲信号的振荡频率
  + cpi，执行一条指令所需要的时钟周期数
  + IPS，每秒执行的指令数
  + FLOPS，每秒中执行多少次浮点运算
+ 数据通路带宽：数据总线一次所能并行传输信息的位数。
+ 吞吐量，值系统在单位时间内处理请求的数量
+ 响应时间：用户向计算机发送一个请求到获得结果的时间

### 检验码

+ BCD码
  + 8421码，只能表示0-9之间的数字，有6为冗余位，如果超过1111,应该加上6进行修正   。
  + 余3码，8421码+（0011）进行一个修正。
  + 2421码，改变权值的定义
+ 奇偶校验码。

  + 这种编码分为奇校验码和偶校验码，顾名思义，就是通过在最高为添加0或者1来保证我们的数据一定有奇数个1或者偶数个1,在数据传输的过程中，我们发现，如果出现某一个为改变了，那么它就不符合最开始规定的奇数个1或者偶数个1,这样的话，我们就可以要求重新传输数据。但是，这样的话，如果自爱数据传输的过程中，我们发现，如果有偶数个1改变了，那么这样的话我们是发现不了错误的。所以这也是奇偶校验码的局限性。

  + 冗余码，普通的二进制的码距为1,这样的编码是没有检查错误的功能的。但是冗余码的码距为1,这样如果其中有一位二进制改变了，那么就一定可以发现错误。
+ 循环冗余码

  + 基本思想：双方先规定好除数和被除数，然后，在接受方收到数据的时候，可以根据这两个进行检验查错。
  + 主要构成：信息位和校验位。
  + 有检错能力，在特定情况下面也有纠错能力。
+ 海明码
  + 将信息分组进行偶校验。
  + 有信息位和校验位。
  + 可以进行差错检测和校验

### 二进制乘除法

+ 二进制原码的乘法：二进制乘法可以和我们进行十进制的乘法进行比较。当我们通过使用的方法是移位进行处理。我们将出发转化为加法进行处理。我们先规定一个乘数x，然后，我们将另一个数字y进行从低位到高位的处理，最后的结果我们记为z。如果该位的二进制数字为1,我们就加上x，然后将z向右移动一位。 同时我们需要记录我们向右一的数字。需要注意的是我们不需要对y的符号位进行处理。当我们计算完成最后一步的时候，我们还需要再进行一次移位的操作
+ 二进制补码的乘法：当我们处理二进制补码的乘法的时候，根据乘数寄存器的最低两位决定，若为00或11,则将上次部分积直接右移一位，若为01，那么就将上次部分积加上[x]补，然后向右移动一位，若为10,那么就将上次部分积加上[-x]补，同时向右边移动一位。最后得到新部分的积。重复n+1次，最后一布移位。
+ 定点位出发，二进制原码进行出发运算，我们使用的是恢复余数法进行处理。我们先假设加上的是[-y]补，如果相加之后的结果为负数，那么我们就需要商0,然后将当前的结果向左移动一位，同时加上[y]补，如果相加之后的结果的符号位是一个正数，那么我们只需要商1,然后我们进行向左移位即可，记住在这个过程中，我们需要记录我们的商的情况。
+ 在进行数据的存储的时候，我们通常可以使用两种方法进行存储数据，一种是大端存储，另一种是小端存储的方法，大端存储是将高字节的数据存放到低地址的存储空间，小端存储的方法与之相反，大端存储的方法更加适合我们阅读，但是小端存储的方法更加适合机器的处理。
+ 在进行字节存储的时候，我们可以进行字节对齐的处理，但是字节对齐的处理可能需要更加耗费时间，因为我们使用这个的话可能需要进行多次将我们的数据装载到内存里面。

### 指令

+ 汇编级机器指令集
  + 分类
    + 数据传送类指令
    + 算术运算类指令
    + 逻辑运算类指令
    + 程序控制类指令
    + 输入输出类指令
    + 特权指令
    + 处理器控制指令
  + 指令格式
    + 指令的格式分为操作码字段和地址码字段

  + 对于地址码，根据指令的地址的个数，我们分为 一级地址，二级地址，零地址，多地址指令等等。
  + 操作码，操作码主要分为两种编码格式，固定长度的格式和可变长度的格式。

+ 数据的寻址方式

  + 指令的寻址方式。分为顺序寻址方式和跳跃寻址方式。
  + 操作数的寻址方式
    + 立即寻址，指令的地址码字段指出的不是操作数的地址，而是操作数本身。
    + 直接寻址，地址码字段直接指出操作数的有效地址。
    + 间接寻址，地址字段中的性质地址不是整数的有效地址，而是操作数的地址的地址。
    + 寄存器寻址，指的是指令中的地址码存储的是某一个通用寄存器的编号。
    + 寄存器间接寻址，地址码中存放的是某一个通用寄存器的编号，在寄存器中存放操作数，而操作数直接存放到主存当中，这是一种普遍使用的一种存储方式。
    + 相对寻址，程序中的程序计数器PC加上指令中的形式地址D，形成了操作数的有效地址。
    + 变址寻址，一个变址存储器中的内容加上位移量D形成操作数的有效地址EA。
    + 基址寻址是将基址寄存器Rb的内容加上指令中给出的偏移地址D相加，得到操作数的有效地址。
    + 段寻址，将一定的存储空间划分为若干段，然后进行寻址的操作。

  + 指令系统中采用不同的寻址方式的目的是缩短指令的长度，扩大寻址空间，提高编程的灵活性。

### 存储器

+ 存储器普遍采用的是半导体存储器
+ CPU与存储器之间通过三组信号线进行物理连接。数据总线，控制总线和地址总线。
+ 存储器的分类，半导体存储器，磁介质存储器和光存储器。按照存储功能，分为随机存储器RAM和只读存储器（ORM)
+ ROM用于存储操作系统的内核。
+ ROM为非易是失存储器，ARM未易失存储器。
+ 存储器的层次分为主存，辅存和高速缓存。

