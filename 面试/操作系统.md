+ 进程和线程的区别

  + 进程是对操作系统的一个正在运行的程序的抽象，进程是资源分配的最小单位。为什么要有进程，进程是为了合理压榨CPU的性能和分配运行的时间片，单个CPU一次只能执行一个任务，如果一个进程跑着，那么唯一一个把CPU完全占住了，这是不合理的。

  + 为什么要有线程？
    + 进程之间通信难以进行数据的共享，父子进程之间没有共享内存，需要通过进程之间通信(IPC),进程之间交换信息，性能开销大。
    + 创建进程的开销大
    
  + 线程
  
    + 一个进程可以由多个线程的执行单元组成，每个线程都运行在进程中，共享着同样的代码和数据。进程之间更加容易共享数据，在上下文切换中一般比进程高效。
  
  + 协程
  
    + 协程是用户态的线程。在创建协程的时候，会从进程的堆中分配一段内存作为协程的栈。
  
    + 优势
  
      + 节省CPU，协程可以避免内核级别线程的上下文切换，避免了CPU资源的浪费。而协程是用户态的线程，用户可以自行进行创建和销毁。从而避免了频繁的系统级别的线程上下文切换。
  
      + 节省内存，在64位的Linux，一个线程通常需要8M的栈内存和64M的堆内存。系统内存的资源限制导致了我们无法开启更多的线程执行高并发，但是协程却可以创建数十万个。
  
      + 稳定性，线程之间通过共享内存来共享数据，如果一个线程出现了问题，同一个进程内的所有的线程都会崩溃。
      + 开发效率，在利用协程进行开发的时候，可以很容易的实现一些IO操作异步化。
+ 协程之间的通信

  + 协程之间一般是通过共享变量的方法来进行通信的，但是这样会给共享内存的多线程造成困难。
  + 在Go语言中，一般是通过channel进行通信的，这种通道方式保证了数据的同步性，同一个时间内只有一个线程可以访问数据，不会出现数据的竞争的现象。
+ 交换空间
  + 当我们的内存不足的时候，我们会将内存中一部分不用的数据放进磁盘空间里面，让出宝贵的内存给需要用的进程。当再次需要这部分的时候再次从磁盘空间里面转到内存中，磁盘空间的那块区间就是我们的交换空间，虚拟内存的空间就是我们的内存空间和磁盘空间的总的空间的大小。
+ 线程和进程的区别
  + 线程和进程都是同步机制，而协程是异步机制。
  + 线程是抢占式的，协程是非抢占式的。在某一个时刻只能有一个线程被执行。
  + 一个线程可以有多个协程，一个进程也可以有多个协程。
  + 协程不被操作系统内核管理，完全是由程序控制，线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。但是协程不会致谢使用线程，而是利用执行器关联任意的线程或者协程池。
  + 协程可以保留上一次调用的时候的状态。
+ 进程和线程的切换流程
  + 进程的切换是通过切换页表来使用新的地址空间，一旦出现了上下文切换，处理器里面所有缓存的内存地址都作废了。
  + 切换内核栈和硬件上下文。
+ 为什么切换虚拟地址空间会比较耗费时间?
  + 每个进程都有自己的虚拟地址空间，把虚拟地址转化为物理地址需要查找页表，查找页表是一个很慢的过程，因此我恩通常使用Cache来缓存常用的地址映射。但是在操作系统里面经常使用Cache来缓存常用的地址映射。这样可以加速页表的查询。
  + 但是在我们进行进程的切换的时候，同时需要进行页表的切换，这样的话，那个Cache缓存的一些地址映射也就消失了。
+ 进程之间的通信
  + 管道。可以分为单向管道和双向管道。分别代表数据流动的方向。同时也可以分为匿名管道和命名管道，匿名管道是一种单向的，一般是用于有亲源关系之间的进程通信使用，还有一种是命名管道，这种管道是以磁盘的方式存在的，可以用于不同的进程之间通信使用。
  + 信号。信号是一种比较复杂的通信方式，信号可以在任何一个时刻发给某一个进程。而无需知道该进程的状态。
  + 信号量。信号量可以理解为一个计时器。可以用来控制多个进程对共享资源的访问。可以作为一种锁的机制。
  + 消息队列。
  + 共享内存。
  + socket通信。主要用于不同的机器之间的进程通信。
+ 进程和线程同步的方式
  + 使用临界区。通过多线程的串行化来访问公共资源或者一段代码。速度快，同时适合控制数据访问。
  + 互斥量。为了协调共同对某一个资源的单独访问而设计的。
  + 信号量。为了控制一个具有有限数量用户资源而设计的，它可以允许多个线程在同一个时刻访问同一个资源，但是对访问这个资源的最大线程的数量有限制。
  + 事件。
+ 线程的分类
  + 线程可以分为用户级线程和内核级线程。内核级的线程指的是内核支持的线程或者是轻量级的线程。无论是在用户程序中创建的线程或者是在系统中创建的线程，它们的创建，销毁都是由内核实现的。
  + 用户级的线程。他们仅存在于用户级别里，他们不依赖于操作系统的核心，利用线程库来完成它的创建和管理。速度比较快，操作系统内核无法感知用户级的线程的存在。
+ 死锁的条件
  + 互斥条件，一个资源一次只能被一个进程所使用
  + 请求和保持条件，一个资源因为请求资源而阻塞的时候，对自己持有的资源保持不放
  + 不可剥夺条件，进程获得资源，在没有完全使用完之前，不能被强行剥夺。
  + 循环等待条件，若干个进程之间形成了一种头尾相接的循环等待关系。
+ 进程调度策略
  + 先来先服务，这个可以使用队列实现。
  + 短作业优先。按照执行的时间长短来进行调度，短的先执行，但是这种调度算法很有可能造成需要长时间服务的作业饿死。
  + 最短剩余时间优先。按照剩余运行时间的顺序进行调度。
  + 时间片轮转。所有进程先排成一个队列，然后，在每次进行调度的时候，把CPU的时间分配给队首进程，同时执行一个时间片，当执行万之后，把这个进程放到队列的尾部去。
  + 优先级调度。为每个进程分配一个优先级，按照优先级进行调度。
+ 讲一下IO多路复用
  + IO多路复用值的是内核一旦发现进程的指定的一个或者多个IO条件准备读取，那么就会通知该进程。