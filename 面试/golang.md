+ 什么是内存逃逸，在什么情况下发生的，原理是什么？
  + 每一段程序，每个函数都有自己的内存区域存放自己的局部变量，返回地址等，这些内存会由编译器在栈中分配，栈空间一般是用来存放函数的参数和一些局部变量的。每个函数在运行的时候都会分配一个栈帧，在函数结束后会自动销毁。但是有些变量我们想在函数结束之后依然可以使用，那么就需要将这些变量分配到堆空间里面，这种从栈上逃逸到堆上的现象就成为了内存逃逸。
  + 虽然，在大多数的语言中都有GC机制，GC机制会对分配到堆上的对象自动管理，当某一个对象不可达的时候，它将会被回收并且重复使用。但是我们在程序中会分配大量的内存，这种情况下就要我们尽量减少在堆上分配内存，一种方法就是让栈中的内存尽可能留在栈里面。
  + 这里我们比较一下堆和栈的分配的内存的区别，在栈中的内存，只需要CPU的两个指令就能进行回收和使用，一个是PUSH，另一个是RELEASE。但是堆中的内存是通过自动分配的，不可预知性比较大，而且容易造成内存碎片，堆上的内存只能通过GC进行回收。所以就需要我们对程序进行逃逸分析，提高程序的运行速度。
  + 几种常见的内存逃逸的情况
    + 函数返回局部指针变量
    + interface类型逃逸
    + 闭包产生的逃逸
    + 变量大小不确定及栈空间不足引发逃逸
  + 如何避免逃逸分析
    + 接口类型的方法是动态调度的，不能在编译阶段就确定下来，所有类型结构转换成接口的过程都会涉及到内存逃逸的情况发生，如果对于性能要求比较高的而且访问频次比较高的函数调用，尽可能避免使用接口类型。
    + 减少外部引用，如指针
    + 在切片使用场景中一般实在函数传递的场景，而且切片可能会涉及动态内存分配。