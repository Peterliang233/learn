+ Mysql的几种索引
  + 索引是什么，索引是一种特殊的文件，它们报刊对数据库里所有记录的引用指针。索引是一种数据结构，数据库的索引，在数据库管理系统是一个排序的结构，以协助快速查询，更新数据库中的数据。索引的实现一般使用B树及其扩展B+树。索引可以提高Mysql的检索速度。
  + 缺点和优点
    + 优点可以加快数据的检索速度。使用索引可以使用优化隐藏器，提高查询的性能
    + 缺点是创建索引和维护索引更加耗费时间，对数据库表格进行增加，删除和修改的时候，索引也需要动态进行修改，会增加增/改/删的效率，同时索引还会占用物理空间。
  + 应用层次来区分有普通索引，唯一索引，复合索引
    + 普通索引：一个索引只包含单列，一个表可以有很多个单列索引
    + 唯一索引：索引的列必须要唯一，可以有空值
    + 复合索引：多个列共同组成一个索引，专门用于组合搜索，效率大于索引合并
    + 聚簇索引：并不是一个单独的索引类型，而是一种数据的存储结构，InnoDB的聚簇索引是在同一个结构里面保存了B-Tree索引和数据行
    + 非聚簇索引，不是聚簇索引。这种索引就是每个节点存储的是一个列对应的主键，先进行非聚簇索引查找到对应的主键，然后执行回表操作进行查找聚簇索引。
  + B树和B+树的区别，B树的将数据分布在树的每个节点之中，B+树是B树的改进版本，B+树的数据都存放到叶子节点上面，而且增加了顺序访问指针，每个叶子节点可以指向相邻的叶子节点。
  + 为什么索引结构默认使用那个B+树，而不是B-树，二叉树，红黑树。
    + B+树的磁盘读写代价更低，B+树的内部节点没有指向关键字的具体信息的指针。内部的节点比B-树更小，如果把所有的同一内部节点的关键字放到同一个磁盘里面，那么盘块所能容纳的关键字的数量也越多，一次性读入内存需要的查找的关键字也是越多。相对IO读写的次数就降低了。
    + 由于B+树的数据只存储在叶子节点里面，分支节点均为索引，方便扫库。只需要扫描一次叶子节点即可。但是B树因为其分支节点同样存储数据，我们要找到具体的数据，就需要进行一次中序遍历来扫，所以B+树更适合区间查询。
    + 不用哈系表的原因是哈希虽然可以快速定位，但是哈系表没有顺序，IO的复杂度高。只有Memory的存储引擎才显式支持哈希表索引。哈系表只适合等值查询，对于非等值查询就不适用了。而且，如果存在大量的重复的键值的情况，哈系表的冲突碰撞就会很大。
    + 二叉树的高度不均匀，不能自平衡，查找的效率和数据有关。
    + 红黑树的高度随着数据的增大而增大，IO代价高。
  + Mysql的最左前缀原则
    + 最左前缀原则就是最左优先，在创建多列索引的时候，根据业务的需求，where子句中使用最频繁的一列放到最左边。
  + 前缀索引，索引的字段很长的时候，这样既占存储空间，又不利于维护，所以可以把很长的字段的前面的公共部分作为一个索引。
+ 哪些mysql的操作会让索引失效
  + or,多列索引,like，where中使用!=,><,where后面使用表达式，where后面使用not in,is not null等
+ MVCC
  + 多版本并发控制。是数据库管理系统一种常见的并发控制，我们知道并发控制常用的是锁。当线程要对一个共享资源进行操作的时候，加锁是一种比较粗暴的方法。这种锁是一种悲观的实现。这会阻塞其它事务，影响数据库的性能。
    + 悲观锁。当一个线程需要对共享资源进行操作的时候，需要对共享资源加锁。这种锁会阻塞其他事务。
    + 乐观锁。当一个线程需要对一个共享资源进行操作的时候，乐观锁通过一个版本控制号，如果操作完成后通过这个版本号判断在该线程操作的过程中是否有其他线程已经对该共享资源进行了操作，那么通知操作失败。mvcc就是一种乐观锁的实现形式。
  + mvcc的两种读形式
    + 快照读，读取的只是当前事务的可见版本。比如简单的select操作。
    + 当前读。读取的是当前的版本，比如特殊的读操作，更新/插入/删除操作。
  + 实现原理
    + Mysql在建表的时候会创建三个隐藏的字段来实现并发版本控制。
    + 在Mysql创建表格的时候，会创建一下三个隐藏字段。
      + RowID，如果在创建表格的时候没有制定主键，那么就会自动使用这个RowID创建一个聚簇索引。
      + DB_TRX_ID，最近修改该记录的事务ID
      + DB_ROLL_PTR,回滚指针，记录上一个版本
    + MVCC通过使用事务ID，回滚指针和删除标识和undo log和可见性算法实现了版本并发控制。
    + read-view，当执行快照读的时候，会创建一个read-view，这个read-view其实只是三个字段。alive_trx_list，记录生成此刻系统中正在活跃的事务id，可以看作是一个数组。up_limit_id，记录上面的alive_trx_list的最小的事务id，low_limint_id，在read-view生成时刻，目前已经出现的事务ID+1
    + 可见性算法
      + 当生成read-viws的时候，我们会拿取DB_TRX_ID和这个read-view的up_limit_id进行比较。如果小于，那么就说明当前事务可见这条记录。否则，执行下一步
      + 判断这条记录的DB_TRX_ID是否大于等于low_limit_id,如果大于等于，说明此事务无法看见这条记录，不然就执行下一步。
      + 判断记录的这条DB_TRX_ID，是否在活跃数组里面，如果在说明这条记录还没有提交，当前操作是事务是不可见的，不在说明是可见的。

