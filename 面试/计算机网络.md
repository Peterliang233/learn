+ 三次握手和四次挥手

  - **什么是TCP**

  - - TCP是一种面向连接的单播协议，在发送数据之前，通信双方需要在彼此之间建立一条连接。所谓的连接，其实就是客户端和服务端的内存里保存的一份关于对方的信息，比如IP地址，端口号等等
    - TCP可以看作是一种字节流，它会处理IP层或以下的层的丢包，重复和错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放到TCP头部

  - - TCP提供一种可靠，面向连接，字节流，传输层的服务，采用三次握手来建立一个连接，四次挥手来释放一个连接。
    - 一个TCP连接分为三个阶段，启动，数据传输和退出。

  - **TCP头部**

  - - 源端口和目的端口在TCP层确认双方进程，序列号表示的是报文段数据中的第一次字节号，ACK是确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1,只有在ACK位启用的时候才有效。
    - 几个状态号的含义：ACK-确认，使得确认号有效，RST-重置连接，SYB-用于初始化一个连接的序列号，FIN-该报文段的发送方已经结束向对方发送数据

  - **状态转换如下图**

  ![img](https://cdn.nlark.com/yuque/0/2021/png/2752815/1637493992028-6ec9e9cf-07c8-4720-aeb7-c02a4bed23a3.png)

  - **三次握手**
  
    - 第一次握手，客户端发送网络包，服务端收到了，这样服务端就得出结论，客户端的发送能力和服务端的接收能力都是正常的。
  
    - 第二次握手，服务端发送包，客户端收到了，这样客户端就可以得到结论，服务端和客户端的发送能力和客户端的接收能力都是正常的。这样客户端就知道了自己的发送能力和接受能力都是正常的。**所以第二次握手的时候客户端就可以确定服务端和客户端是否可以正常通信。**
    - 第三次握手，客户端发送数据包，服务端收到了。在第一二次握手的阶段，**服务端不知道客户端的接收能力和自己的发送能力是否正常**。但是在第三次握手的时候，服务端收到了客户端对自己的第二次握手的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接受到了，所以，我的发送能力是正常的，客户端的接受能力是正常的。
  
  - 通过了以上三次握手，客户端和服务端就都知道了对方和自己的发送能力和接受能力都是正常的。接下来就是正常的通信了。
  - **更加专业化的语言描述三次握手**
  - - 客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c)
  - 服务端发送自己的SYN段作为应答，同时指明自己的ISN(s).为了确认客户端的SYN，将ISN(c)+1作为ACK的值，这样，每次发送一个SYN，序列号就会加1,如果有丢失的情况，就会重传。
  - - 为了确认服务器的SYN，客户端需要将SYN(s)+1作为返回的ACK的值
- **四次挥手**
  - - 当客户端和服务端的一方想要关闭连接的时候，会发送指令告知对方（一次），我要关闭连接了。这个时候对方会返回一个ACK，表示同意你这个方向的连接（两次）。**然后此时一个方向的连接已经关闭了**。但是可能对方正在传输数据，所以需要等到所有的数据都传输完毕之后，对方发送一个FIN来关闭此方向的连接（三次），接受方接收到后发送一个ACK来确认关闭连接（四次）。
  - **更加专业化的语言描述四次挥手**
- - 客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K，同时还包含一个ACK表示确认对方最近一次发过来的数据
    - 服务端将K值加1作为ACK序列值，表明收到一个包，这时上层的程序将会被告知另一端发起了关闭操作。
- - 服务端发送一个FIN段，ACK=K+1，Seq=L
    - 客户端发送确认，ACK=L+1
- **为什么建立连接是三次握手，断开连接确是四次挥手？**
  - - 这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文段后，**把ACK和SYN放到一个报文里面发送给客户端**;关闭连接时，当收到对方的FIN报文段的时候，仅仅表示对方不再发送数据了，但是对方还是可以接收数据，己方是否现在关闭数据通道，需要由上层决定。因此，**己方的ACK和FIN通常是分开的。**

+ HTTP断点续传

  + 使用的是HTTP1.0协议，通过在header的两个参数实现的，客户端的是Range，服务端的是Content-Range
  + Range，指定第一个字节的位置和最后一个字节的位置
  + Content-Range,返回当前的接受范围和文件的大小
  + 增强校验
    + 在实际场景中，可能进行断点续传的时候出现url的文档内容在服务器段已经发生了改变，此时，我们使用Last-Modified来标识文件的最后的修改时间，Last-Modified是服务器发送到客户端的HTTP头，Last-Modified-Since是客户端发送到服务端的请求头，发送请求的时候，客户端会先回将Last-Modified-Since发送到服务端，服务端进行校验是否是最新的，如果不是最新的，那么就会返回最新的内容

  + Etag，是为了解决Last-Modified不能解决的一些问题，有些文件是周期性改变的，但是内容没有改变，我们希望客户端不希望认为这些文件是改变了的。某些文件频繁修改，但是Last-Modified的感知是s级别的。这种修改是无法判断的。某些服务器不能得到精确的最后的修改时间。Etag比Last-Modified的作用是类似的，但是功能比它强。
  + if-Range,如果实体没有改变，那么返回剩下的部分，否则，重新发送整个实体。

  + 工作原理
    + 第一次请求，客户端发送一个HTTP GET请求，服务器处理请求，返回文件的内容以及相关的header，其中包括Etag
    + 第二次请求（断点续传），客户端发送一个http GET请求，同时发送If-Range
    + 服务端判断收到的Etag和计算Etag是否匹配。
+ HTTP 状态码

  + 1xx，指信息，表示请求已经接受，继续处理
  + 2xx，表示请求已经被成功接收，理解和接受
    + 200,OK,请求正常理解
    + 204,请求处理成功，但是没有资源返回
    + 206,对资源的某一部分的请求
  + 3xx，重定向，完成请求必须进行更近一步的操作
    + 301,永久重定向，请求的资源已经被永久迁移到新的url里面，今后任何新的请求都通过这个新的url进行访问。
    + 302,临时重定向，资源只是临时被移动，客户端可以继续请求原有的url
    + 304,缓存中读取，未修改，所请求的资源未修改，不返回任何资源，客户端通常会缓存访问过的资源
  + 4xx，客户端读错误，请求语法错误，或者请求无法实现
    + 400, 请求报文中语法错误
    + 401,请求未经过授权，需要有同感http认证的认证信息
    + 403,服务器收到请求，但是拒绝提供服务
    + 404,无法找到请求资源
  + 5xx，服务端错误，服务端未能实现合法的请求
    + 500, 服务器执行的时候发生错误
    + 503,服务器处于超负荷或者正在停机维护
+ http和https的区别
  + http以明文的方式发送数据。不提供任何的数据加密。容易被网站的攻击者截获数据。
  + https超文本安全传输协议。同样是使用http进行通信，但是将数据包通过TLS/SSL进行加密。是提供对网站服务器的身份认证，保护交换数据的隐私与完整性的一种协议。




