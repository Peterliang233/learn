### 分布式锁的实现方案

+ 首先，我们需要知道为什么需要分布式锁，当我们的服务是高并发的情况下，就比如秒杀系统，我们的数据只有一份或者若干份，我们需要控制并发程序的处理，只有拿到了锁的才可以走某一段代码逻辑。这样的话我们就需要利用分布式锁来实现。
+ 设计分布式锁需要实现一把可重新入锁，不需要的时候可以释放锁。

+ 主要有三种，分别是利用mysql，redis和zookeeper实现

  + mysql实现
    + 当许多线程抢占锁的时候，如果某一个线程拿到了锁，那么我们就在mysql里面插入一条数据，表示这个线程拿到了锁。当这个线程处理完成之后，我们就需要在数据库里面删除这条记录，以便其他线程可以继续来抢占锁。由于mysql自身是带有事务特性的。所以满足分布式系统的三大特点CAP，一致性，可用性和分区容错性。
    + 但是在高并发的情况下，对数据库的链接的开销是无法忍受的。
    + 缺点：数据库是单点的，一旦数据库系统挂掉，就会导致服务不可以用。同时一旦解锁的时候出错了，那么这把锁就会一直占用。这个锁是非阻塞的，一旦插入失败就会报错，其他没有拿到锁的线程不会进入等待队列进行重新抢夺锁。同一个线程获得锁不是可以重入的。因为这个数据库里面已经有这条数据了。还有就是锁没有过期时间。
  + redis实现
    + redis，多个线程一起抢占锁，如果某一个线程拿到了锁，那么我们就在redis里面设置一个key。同时设置过期时间，在执行完逻辑代码之后，我们就可以删除这把锁。
      + 存在问题
        + 可能存在设置了键，但是设置过期时间的时候失效了。解决办法：使用SETNX命令。如果键不存在的时候才会设置这个键，同时还可以设置过期时间。
        + 释放锁的时候和或得锁的时候不是同一条命令，没有原子性。解决办法：采用lua脚本，将两条命令打包成一条命令，这样就可以实现原子性了。
    + 但是还是有问题，就是假如我们设置的过期时间是相对较短，但是这个任务执行的时间又比较长，那么任务还没有执行完锁就被释放了。
    + 这里我们引入一个redisson，redisson有一个类似与看门狗的机制，就是会监听这个执行的任务，每当这个任务执行到过期时间的三分之一的时候，就会自动续锁。还有一种办法就是当我们解锁的时候发现如果有其他线程拿到了这些锁的话，就会执行回滚机制。
    + redlock实现
      + 假设我们有n个节点，这些节点完全是独立的，为了得到锁，客户端应该依次向N个服务器发送取锁的请求，如果一个超时了就立马向下一个申请，总的流程走下来如果有N/2+1个节点都取到了锁，那么就说明是拿到了锁。但是在解锁的时候需要对每个节点都执行解锁的操作。这里需要注意一个**时钟机制和节点宕机**的情况。
    + 这种的实现对数据的安全性要求不是那么高，但是性能相对较好。

  + zookeeper的实现
    + zookeeper实现分布式锁的方法是首先先创建一个locks目录，然后当某一个进程得到了锁的时候，就在这个目录下面创建一个新的节点，同时给每个节点一个编号，对子节点按照编号的从小到大进行编号，编号小的就得到了锁。当线程释放锁的时候，就会删除这个节点。当zookeeper监听到自己的节点被删除之后，就会去重新判断。
    + 这种的实现对数据的安全性特别高，但是性能不是很好。

### rpc

