### 数据结构

+ redis的数据类型

  + 字符串string
    + 如果保存的字符串是一个数字，那么就用long类型来表示，如果保存的元素的长度少于39,那么就使用embstr编码来进行保存，否则就使用SDS来进行保存。
  + 哈希hash
    + 底层的实现有ziplist和hashtable。
    + 哈系对象保存的所有键值对的字符串的长度都是小于64并且元素的个数少于512,就使用ziplist，否则就使用hashtable
  + 列表list
    + list是有序可以重复的列表，查询速度快，通过索引进行查找。
    + 底层可以是ziplist或者是linklist，保存的数据长度小或者是元素的个数少的话就使用ziplist，否则就是使用linklist。
  + 集合set
    + set和list都可以存储多个字符串，但是list是有序可以重复的，set是无序不可以重复的。
    + 底层的编码可以是inset或者是hashtable，对象的个数少于512,使用inset，否则是使用hashtable
  + 有序集合 sorted set
    + 和哈希表一样，可以存储键值对，键就是我们的元素，值是一个浮点数，集合里面是按照浮点数来进行排序的
    + 底层可以使用ziplist或者skiplist
  + 有序集合zset
    + zset的底层存储结构包括ziplist和skiplist，在同时满足两个条件的时候使用ziplist，其他使用skiplist
    + 有序集合的保存的元素的数量少于128个
    + 有序集合保存的所有元素的长度小于64个字节
    + ziplist作为底层存储结构的时候，一个元素使用两个节点紧挨在一起的压缩列表节点来保存。第一个节点保存成员的元素，第二个节点保存元素的分值。
    + 使用skiplist作为底层存储结构的时候，使用skiplist按序保存元素及其分值，使用dict字典来保存元素和分支的映射关系。
  + 这里重点介绍一下skiplist，也就是我们所说的跳跃表，跳跃表其实是一种链表，这种链表划分了很多级别的索引，然后根据这些索引，我们可以实现一种类似于二分查找的方法来快速地找到我们所需要的值。查询的性能堪比红黑树和AVL。可以类比一颗树，然后哦我们从根节点开始向下开始进行查找，查询的时间复杂度为log级别的。但是由于建立了很多的索引，所以空间复杂度是比较大的。

### 持久化机制

+ redis的持久化机制

  + 为了防止系统故障，redis提供了两种持久化方法将数据存储在磁盘中。一种是快照RDB，另一种是只追加文件AOF
  + RDB是在指定的时间间隔内将内存中的数据集快照写入磁盘，它恢复时将快照文件直接读入到内存中。Redis会创建一个子进程进行持久化，会先将数据写入一个临时的文件里面，然后等持久化完成之后，会用临时文件将上次的持久化的文件替换掉。主进程不会进行IO操作。如果数据量大而且对数据的完整性不是那么敏感，可以使用RDB的方式，RDB的缺点是最后一次持久化的数据可能会丢失。数据保存在dump.rdb文件里面。恢复RDB文件只需要将dump.rdb文件放到redis安装目录然后启动服务即可。
  + AOF是以日志的形式记录每个写操作，将redis执行过的命令记录到文件里面，只追加文件不能改写文件。redis启动之初会读取该文件重新构建数据。aof文件可以确保数据的完整性。
+ 对比两种持久化的方式，我们可以知道，RDB文件是对数据进行持久化，而AOF是对执行的命令进行持久化。

### 过期策略

+ redis的过期键策略
  + 定时删除，每个设置过期时间的key都需要创建一个定时器，到了过期时间就会自动清除，该策略可以立刻清除过期的数据。
  + 惰性删除，为每个键设置一个过期时间，在我们每次访问一个键的时候，我们先判断是否过期，如果过期，那么就把这个过期键删除。
  + 定期删除，每隔一段时间，扫描数据库里面的一定数量带有expire的一定数量的key，然后我们清除已经过期的key，这种策略是前两种的一种折中的方案。
+ redis的内存淘汰策略（这种策略一般是用于redis的缓存不足的时候）
  + 当内存不足以容纳新的写入的数据的时候，新写入的操作就会报错
  + 当内存不足以容纳新的写入的数据的时候，在键空间里面，会移除最少使用的key
  + 当内存不足以容纳新的写入的数据的时候，会随机移除一个key
  + 当内存不足以容纳新的写入的数据的时候，会删除一个最近最少使用的key
  + 当内存不足以容纳新的写入的数据的时候，会在所有设置了过期的键空间里面，随机删除一个key
  + 当内存不足以容纳新的写入的数据的时候，会在设置了过期时间的键空间里面，删除一个最早过期的key
  + LFU，记录键的使用频率来定位最可能淘汰的键
+ Redis的缓存雪崩，缓存击穿，缓存穿透？
  + 缓存穿透是指在某一个时刻在缓存里面查询某一个值，但是这个键过期了， 所以需要到数据库里面查询这个数据，进而给数据库带来压力。解决的方法是在api入口就对这个请求进行校验，让非法的请求不进入之后的逻辑，还有就是给缓存设置空值或者是默认值，如果有请求进来的时候需要先更新缓存，还有就是利用布隆过滤器进行过滤，如果命中了对应的规则，请求才继续向下进行。
  + 缓存击穿是指在某一个时刻有一个key过期了，但是恰好在这个时候有大批的这个Key的请求进入，导致了每次请求都对磁盘进行读写操作。解决的方法是加上锁，让请求具有原子性，另外就是设置缓存永不过期，也就是在缓存将要过期的时候开一个线程去设置他们的过期时间。
  + 缓存雪崩是指某一个时刻有大量的Key过期了，造成请求每次都需要从DB里面重新读取，造成了服务器宕机等等。解决的方法是合理设置不同的key的过期的时间，或者是搭建高可用集群。


### 性能分析

+ redis为什么快？

  + 基于内存实现的，想对于数据存在磁盘的数据库，省去了磁盘的IO消耗。

  + 高级的数据结构实现。

    + SDS 简单动态字符串

      + ```Go
        struct sdshdr{
            int len;  // 记录buf已经使用的空间
            int free;  // buf中的空闲部分的长度
            char buf[];  // 存储的实际内容
        }
        ```

      + SDS的优势是减少内存的重新分配的次数，通过空间预分配和堕性空间的释放实现。

    + 哈希

      + Redis作为一个K-V内存数据库。使用一张哈希表来存储所有的键值对，一张哈希表有多个哈希桶组成，每个桶里的entry元素保存了key,val指针。
      + 数据量过大造成冲突怎么办？通过使用链式哈希，在同一个哈希桶里面，使用一个哈希链表来保存多个元素。各个元素之间使用结点相连。
      + 如果某一条哈希链表太长了怎么办？我们通过执行rehash操作，减少冲突。使用两个全局哈希表，一个作为主哈希表，另一个作为扩容使用。

    + 跳跃表

      + 跳跃表就是在链表的基础上，增加多级索引。分为若干层，每一层都是一个有序的链表，最底层的链表包含了所有的元素。

    + 压缩列表ziplist

      + 压缩列表是列表键和字典键的底层实现之一。是一系列特殊编码的内存块构成的列表。内存是连续分配的

  + 合理的数据编码

    + Redis支持多数据基本类型，每种基本类型都是对应这不同的数据结构，每种数据结构对应着不同的编码。

  + 合理的线程模型

    + 单线程模型，避免了上下文切换。redis的网络IO和键值对读写都是通过一个线程实现的，但是对于一些其他的功能，比如异步删除，持久化等是用额外的线程执行的。
    + redis的单线程模型避免了CPU的不必要的上下文切换和竞争锁的消耗。

  + IO多路复用

    + IO指网络IO，多路是指多个网络连接，复用是指复用同一个线程。IO多路复用其实就是一种同步IO模型，一个线程监听多个文件句柄，如果某一个文件句柄准备就绪，那么就通知应用程序执行相应的读写操作，如果此时没有任何的文件句柄就绪，那么此线程阻塞，交出CPU。
    + 多路复用技术可以让某一个线程高效率的处理多个连接请求，而redis使用epoll作为IO多路复用技术的实现，并且redis自身的时间处理模型将epoll中的连接，删除，关闭等转化为事件，不在网络IO浪费过多时间。

  + 虚拟内存机制

    + redis直接自己构建了一个VM机制。不会像一般的系统调用系统函数处理。
    + Redis的虚拟内存机制就是将内存中不经常访问的数据从内存中交换到磁盘中，这部分我们成为冷数据，从而腾出宝贵的内存空间给其他需要被访问的数据，这部分我们称为热数据。redis通过VM实现了冷热数据的分离。使得冷数据在磁盘中，热数据在内存中，避免内存不足造成的访问速度下降的问题。
  
+ redis6.0之后为什么又改用多线程了

  + redis的性能瓶颈主要是网络的io，而不是cpu，用多线程来处理数据的读写，而对于客户端的命令的执行还是采用的单线程的。

+ redis的底层采用的是RESP协议，这种协议底层简单，解析速度快，可读性好。

### 集群

+ 主从复制的三个阶段

  + 建立连接的过程，这个过程就是slave和master连接的过程，主要进行的是socket连接，进行身份验证，发送slave的端口信息等等。
+ 数据同步阶段过程。首先执行一个全量复制，然后执行一个部分复制。
  + 命令传播阶段。当master数据库被修改之后，主从服务器的数据不一致。这个时候就需要我们同步主从数据。这个过程就是命令传播方式。master将收到的数据变更命令发送给slave节点。slave节点执行对应的命令实现同步。
+ 心跳机制。
+ 哨兵模式
  + 哨兵模式是为了当主节点宕机的时候，需要选举一个从节点重新成为主节点。这个时候就需要有一台哨兵服务器来监控各个主和从节点，我们一般采用的是多台哨兵，同时哨兵之间还可以进行相互监控。
  + 主要的过程
    + 发送命令，等待redis服务器返回其运行状态
    + 哨兵检测到主要节点宕机了，通过发布订阅模式通知其他从节点，修改他们的配置文件，让某一个从节点成为主节点
    + 哨兵之间相互监控，防止出现哨兵也挂了的情况。
  + 故障切换的过程
    + 某一台哨兵服务器监听到主服务器宕机了， 但是不会立马判断，如果多个哨兵都监听到了，那么有一台哨兵服务器就会发起投票，进行failover的操作，切换成功之后，就会通过发布订阅模式通知到对应的从服务器。
  + 哨兵在监控其他服务器的时候，一般是每10s发送一次心跳检测，如果发现某一台服务器下线了，他会改为每1s发送一次再次进行确认。
+ cluster集群
  + 哨兵模式是主从分离的，但是每台服务器存储的数据都是一样的，不利于在线扩容，所以可以使用cluster集群来实现分布式存储数据。对数据进行分片，然后存储到不同的节点上面。
  + 这种集群的节点之间通过的是gossip协议实现的，节点之间交换的信息主要是节点出现故障，新节点的加入，主从节点的变更信息。
+ 分布式锁
  + 分布式锁是控制分布式系统不同进程共同访问共享资源的一种锁的实现。
  + 使用Redisson来实现，这种的方法是在获取了锁的线程中开启一个守护线程，这个线程每隔一段时间来看这个锁是否存在，同时给锁的过期时间延长，防止锁的提前释放。

### 事务

+ redis的事务
  + redis的事务是一组命令的集合，将多个命令进行打包，然后将这些命令按照顺序添加到队列里面，按照顺序执行这些命令。
  + 分为一下步骤：开始事务，命令入队，执行事物，撤销事务。
  + 采用的是顺序性，一致性和排他性，会按照顺序串行化执行队列里面的命令。

### 其他

+ redis是如何保证双写一致性的（双写一致性就是mysql和redis同时写的时候如何保证数据的一致性）

  + 缓存延时双删：先删除缓存，再更新数据库，然后再删除缓存。
  + 延时双删会有以下三种策略
    + 先更新数据库，再更新缓存。这种的如果两个线程同时对一条数据进行操作，可能会造成脏读的问题。而且，如果是写数据库比较多的场景，这种的也是比较不合理的，缓存会被频繁更新，影响性能。
    + 先更新数据库，再删除缓存。先把数据放到数据库里面，如果成功之后，再让缓存失效。
    + 先删除缓存，再更新数据库。这里就是我们采用的延时双删的机制了。我们先删除缓存，在更新数据库，更新完数据库之后再删除对应的缓存。

  + 删除缓存重试机制：第二次删除缓存失败就多删除几次。可以把失败的key放到消息队列里面进行消费，消费失败就多删除几次。（但是这种的会对业务代码造成比较大的入侵）

  + 通过biglog来实现异淘汰key。