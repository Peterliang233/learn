+ zset的底层结构
  + zset的底层存储结构包括ziplist和skiplist，在同时满足两个条件的时候使用ziplist，其他使用skiplist
    + 有序集合的保存的元素的数量少于128个
    + 有序集合保存的所有元素的长度小于64个字节
  + ziplist作为底层存储结构的时候，一个元素使用两个节点紧挨在一起的压缩列表节点来保存。第一个节点保存成员的元素，第二个节点保存元素的分值。
  + 使用skiplist作为底层存储结构的时候，使用skiplist按序保存元素及其分值，使用dict字典来保存元素和分支的映射关系。
  
+ redis的数据类型

  + 字符串string
  + 哈希hash
  + 列表list
  + 集合set
  + 有序集合zset
  
+ redis的持久化机制

  + 为了防止系统故障，redis提供了两种持久化方法将数据存储在磁盘中。一种是快照RDB，另一种是只追加文件AOF
  + RDB是在指定的时间间隔内将内存中的数据集快照写入磁盘，它恢复时将快照文件直接读入到内存中。Redis会创建一个子进程进行持久化，会先将数据写入一个临时的文件里面，然后等持久化完成之后，会用临时文件将上次的持久化的文件替换掉。主进程不会进行IO操作。如果数据量大而且对数据的完整性不是那么敏感，可以使用RDB的方式，RDB的缺点是最后一次持久化的数据可能会丢失。数据保存在dump.rdb文件里面。恢复RDB文件只需要将dump.rdb文件放到redis安装目录然后启动服务即可。
  + AOF是以日志的形式记录每个写操作，将redis执行过的命令记录到文件里面，只追加文件不能改写文件。redis启动之初会读取该文件重新构建数据。aof文件可以确保数据的完整性。
  
+ 对比两种持久化的方式，我们可以知道，RDB文件是对数据进行持久化，而AOF是对执行的命令进行持久化。

+ redis的过期键策略
  + 定时删除，每个设置过期时间的key都需要创建一个定时器，到了过期时间就会自动清除，该策略可以立刻清除过期的数据。
  + 惰性删除，为每个键设置一个过期时间，在我们每次访问一个键的时候，我们先判断是否过期，如果过期，那么就把这个过期键删除。
  + 定期删除，每隔一段时间，扫描数据库里面的一定数量带有expire的一定数量的key，然后我们清除已经过期的key，这种策略是前两种的一种折中的方案。
  
+ redis的内存淘汰策略（这种策略一般是用于redis的缓存不足的时候）
  + 当内存不足以容纳新的写入的数据的时候，新写入的操作就会报错
  + 当内存不足以容纳新的写入的数据的时候，在键空间里面，会移除最少使用的key
  + 当内存不足以容纳新的写入的数据的时候，会随机移除一个key
  + 当内存不足以容纳新的写入的数据的时候，会删除一个最近最少使用的key
  + 当内存不足以容纳新的写入的数据的时候，会在所有设置了过期的键空间里面，随机删除一个key
  + 当内存不足以容纳新的写入的数据的时候，会在设置了过期时间的键空间里面，删除一个最早过期的key
  + LFU，记录键的使用频率来定位最可能淘汰的键
  
+ redis为什么快？

  + 基于内存实现的，想对于数据存在磁盘的数据库，省去了磁盘的IO消耗。

  + 高级的数据结构实现。

    + SDS 简单动态字符串

      + ```Go
        struct sdshdr{
            int len;  // 记录buf已经使用的空间
            int free;  // buf中的空闲部分的长度
            char buf[];  // 存储的实际内容
        }
        ```

      + SDS的优势是减少内存的重新分配的次数，通过空间预分配和堕性空间的释放实现。

    + 哈希

      + Redis作为一个K-V内存数据库。使用一张哈希表来存储所有的键值对，一张哈希表有多个哈希桶组成，每个桶里的entry元素保存了key,val指针。
      + 数据量过大造成冲突怎么办？通过使用链式哈希，在同一个哈希桶里面，使用一个哈希链表来保存多个元素。各个元素之间使用结点相连。
      + 如果某一条哈希链表太长了怎么办？我们通过执行rehash操作，减少冲突。使用两个全局哈希表，一个作为主哈希表，另一个作为扩容使用。

    + 跳跃表

      + 跳跃表就是在链表的基础上，增加多级索引。分为若干层，每一层都是一个有序的链表，最底层的链表包含了所有的元素。

    + 压缩列表ziplist

      + 压缩列表是列表键和字典键的底层实现之一。是一系列特殊编码的内存块构成的列表。内存是连续分配的

  + 合理的数据编码

    + Redis支持多数据基本类型，每种基本类型都是对应这不同的数据结构，每种数据结构对应着不同的编码。

  + 合理的线程模型

    + 单线程模型，避免了上下文切换。redis的网络IO和键值对读写都是通过一个线程实现的，但是对于一些其他的功能，比如异步删除，持久化等是用额外的线程执行的。
    + redis的单线程模型避免了CPU的不必要的上下文切换和竞争锁的消耗。

  + IO多路复用

    + IO指网络IO，多路是指多个网络连接，复用是指复用同一个线程。IO多路复用其实就是一种同步IO模型，一个线程监听多个文件句柄，如果某一个文件句柄准备就绪，那么就通知应用程序执行相应的读写操作，如果此时没有任何的文件句柄就绪，那么此线程阻塞，交出CPU。
    + 多路复用技术可以让某一个线程高效率的处理多个连接请求，而redis使用epoll作为IO多路复用技术的实现，并且redis自身的时间处理模型将epoll中的连接，删除，关闭等转化为事件，不在网络IO浪费过多时间。

  + 虚拟内存机制

    + redis直接自己构建了一个VM机制。不会像一般的系统调用系统函数处理。
    + Redis的虚拟内存机制就是将内存中不经常访问的数据从内存中交换到磁盘中，这部分我们成为冷数据，从而腾出宝贵的内存空间给其他需要被访问的数据，这部分我们称为热数据。redis通过VM实现了冷热数据的分离。使得冷数据在磁盘中，热数据在内存中，避免内存不足造成的访问速度下降的问题。
  
  + 主从复制的三个阶段
    + 建立连接的过程，这个过程就是slave和master连接的过程，主要进行的是socket连接，进行身份验证，发送slave的端口信息等等。
    + 数据同步阶段过程。首先执行一个全量复制，然后执行一个部分复制。
    + 命令传播阶段。当master数据库被修改之后，主从服务器的数据不一致。这个时候就需要我们同步主从数据。这个过程就是命令传播方式。master将收到的数据变更命令发送给slave节点。slave节点执行对应的命令实现同步。
    + 心跳机制。