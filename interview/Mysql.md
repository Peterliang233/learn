+ Mysql的几种索引
  + 索引是什么，索引是一种特殊的文件，它们报刊对数据库里所有记录的引用指针。索引是一种数据结构，数据库的索引，在数据库管理系统是一个排序的结构，以协助快速查询，更新数据库中的数据。索引的实现一般使用B树及其扩展B+树。索引可以提高Mysql的检索速度。
  + 缺点和优点
    + 优点可以加快数据的检索速度。使用索引可以使用优化隐藏器，提高查询的性能
    + 缺点是创建索引和维护索引更加耗费时间，对数据库表格进行增加，删除和修改的时候，索引也需要动态进行修改，会增加增/改/删的效率，同时索引还会占用物理空间。
  + 应用层次来区分有普通索引，唯一索引，复合索引
    + 普通索引：一个索引只包含单列，一个表可以有很多个单列索引
    + 唯一索引：索引的列必须要唯一，可以有空值
    + 复合索引：多个列共同组成一个索引，专门用于组合搜索，效率大于索引合并
    + 聚簇索引：并不是一个单独的索引类型，而是一种数据的存储结构，InnoDB的聚簇索引是在同一个结构里面保存了B-Tree索引和数据行
    + 非聚簇索引，不是聚簇索引。这种索引就是每个节点存储的是一个列对应的主键，先进行非聚簇索引查找到对应的主键，然后执行回表操作进行查找聚簇索引。
  + B树和B+树的区别，B树的将数据分布在树的每个节点之中，B+树是B树的改进版本，B+树的数据都存放到叶子节点上面，而且增加了顺序访问指针，每个叶子节点可以指向相邻的叶子节点。
  + 为什么索引结构默认使用那个B+树，而不是B-树，二叉树，红黑树。
    + B+树的磁盘读写代价更低，B+树的内部节点没有指向关键字的具体信息的指针。内部的节点比B-树更小，如果把所有的同一内部节点的关键字放到同一个磁盘里面，那么盘块所能容纳的关键字的数量也越多，一次性读入内存需要的查找的关键字也是越多。相对IO读写的次数就降低了。
    + 由于B+树的数据只存储在叶子节点里面，分支节点均为索引，方便扫库。只需要扫描一次叶子节点即可。但是B树因为其分支节点同样存储数据，我们要找到具体的数据，就需要进行一次中序遍历来扫，所以B+树更适合区间查询。
    + 不用哈系表的原因是哈希虽然可以快速定位，但是哈系表没有顺序，IO的复杂度高。只有Memory的存储引擎才显式支持哈希表索引。哈系表只适合等值查询，对于非等值查询就不适用了。而且，如果存在大量的重复的键值的情况，哈系表的冲突碰撞就会很大。
    + 二叉树的高度不均匀，不能自平衡，查找的效率和数据有关。
    + 红黑树的高度随着数据的增大而增大，IO代价高。
  + Mysql的最左前缀原则
    + 最左前缀原则就是最左优先，在创建多列索引的时候，根据业务的需求，where子句中使用最频繁的一列放到最左边。
  + 前缀索引，索引的字段很长的时候，这样既占存储空间，又不利于维护，所以可以把很长的字段的前面的公共部分作为一个索引。
+ 哪些mysql的操作会让索引失效
  + or,多列索引,like，where中使用!=,><,where后面使用表达式，where后面使用not in,is not null等
+ MVCC
  + 多版本并发控制。是数据库管理系统一种常见的并发控制，我们知道并发控制常用的是锁。当线程要对一个共享资源进行操作的时候，加锁是一种比较粗暴的方法。这种锁是一种悲观的实现。这会阻塞其它事务，影响数据库的性能。
    + 悲观锁。当一个线程需要对共享资源进行操作的时候，需要对共享资源加锁。这种锁会阻塞其他事务。
    + 乐观锁。当一个线程需要对一个共享资源进行操作的时候，乐观锁通过一个版本控制号，如果操作完成后通过这个版本号判断在该线程操作的过程中是否有其他线程已经对该共享资源进行了操作，那么通知操作失败。mvcc就是一种乐观锁的实现形式。
  + mvcc的两种读形式
    + 快照读，读取的只是当前事务的可见版本。比如简单的select操作。
    + 当前读。读取的是当前的版本，比如特殊的读操作，更新/插入/删除操作。
  + 实现原理
    + Mysql在建表的时候会创建三个隐藏的字段来实现并发版本控制。
    + 在Mysql创建表格的时候，会创建一下三个隐藏字段。
      + RowID，如果在创建表格的时候没有制定主键，那么就会自动使用这个RowID创建一个聚簇索引。
      + DB_TRX_ID，最近修改该记录的事务ID
      + DB_ROLL_PTR,回滚指针，记录上一个版本
    + MVCC通过使用事务ID，回滚指针和删除标识和undo log和可见性算法实现了版本并发控制。
    + read-view，当执行快照读的时候，会创建一个read-view，这个read-view其实只是三个字段。alive_trx_list，记录生成此刻系统中正在活跃的事务id，可以看作是一个数组。up_limit_id，记录上面的alive_trx_list的最小的事务id，low_limint_id，在read-view生成时刻，目前已经出现的事务ID+1
    + 可见性算法
      + 当生成read-view时候，我们会拿取DB_TRX_ID和这个read-view的up_limit_id进行比较。如果小于，那么就说明当前事务可见这条记录。否则，执行下一步。如果事务ID小于当前活跃的事务id里面的最小的id，那么说明我们这个查询操作是在很早之前就开始了，说明此时读取的数据对于现在来说都是可见的。
      + 判断这条记录的DB_TRX_ID是否大于等于low_limit_id,如果大于等于，说明此事务无法看见这条记录，不然就执行下一步。如果此时的事务id大于当前所有的事务id，那么说明我们得到的所有的事务id都在这个事务id之后，此时读取的还不是确定的。所以这个是不可见的。
      + 判断记录的这条DB_TRX_ID，是否在活跃数组里面，如果在说明这条记录还没有提交，当前操作是事务是不可见的，不在说明已经提交了所以是可见的。如果进行快照读的时候，这个事务id还在当前的活跃的事务里面，那么说明此时这些事务还没有提交，保存到磁盘里面，所以这是不可见的。
+ 乐观锁的实现
  + 版本号控制。通过设置数据被修改的次数，当数据被修改的时候，这个字段就会加1。所以，我们只需要比较读之前和读取之后的版本号就可以判断是否满足乐观锁的实现了。
  + $CAS$算法。比较并且交换。是一种有名的无锁算法。无锁编程。即不用锁的情况下实现多线程之间的变量同步。所以也叫做非阻塞同步。CAS算法涉及到三个操作数。
    + 需要读写的内存值V,这个可以理解为初始的版本
    + 进行比较的值A，这里可以理解为读取之后的版本
    + 拟写入的新值B
  + 当且仅当V的值为A的时候（如果两个版本都是一样的，那么说明这个值没有被其它线程访问），$CAS$通过原子操作用新值B进行更新V的值。否则不会执行任何操作。一般情况下，这是一个自旋的操作，即不断的尝试。
  + cas算法会有一个ABA问题，就是你这个线程读取的时候得到一个值A，然后另一个线程进行修改得到一个值B，然后这个线程又将这个值修改成了A，那么你读取的内存值和预期值其实还是一样的。但是其实这两个变量已经不是同一个变量了。
  + ABA问题出现的原因是你的变量变化是可以出现环形的，为了解决这个问题，我们可以使用在单个方向进行变化的进行处理，比如一个自增的主键ID。同时我们可以增加一个版本信息和时间戳进行解决。
+ 悲观锁的实现
  + 悲观锁一把是使用信号量实现的。在数据库里面使用的是行级锁来进行处理。
+ 谈谈事务
  + 事务的实现主要依赖于两个log，一个是redo-log，另一个是undo-log。每次事务都会在记录的数据修改前进行数据的undo-log，进行上一个版本的数据的备份。成功修改之后数据放入redo-log,提交成功之后则使用redo-log存储进磁盘空间里面。失败则使用undo-log则恢复到事务修改之前的数据。
+ bin_log,redo_log,undo_log三者的区别
  + bin_log是Mysql_server实现的，是一个逻辑日志，类似与存储的是SQL脚本，不会覆盖之前的版本。可以用于主从复制的搭建。
  + redo_log是是存储引擎特有的，是一个物理日志，记录的是在某一个数据页面进行了什么修改。这个文件是一个循环写入的。主要用于服务器宕机和介质故障的数据恢复使用。
  + undo_log提供了多个版本之间的并行控制和回滚。我们通过记录每次执行某种操作之前的数据，当这个事务失败的时候，我们提供了事务的回滚操作。
+ 数据库的三大范式
  + 第一范式，数据库的每列的数据不可分解。
  + 第二范式，在满足第一范式的基础上，非主键属性需要完全依赖主键，不可以部分依赖主键。
  + 第三范式，在满足第一范式和第二范式的基础上，非主键属性不能依赖于主键之外的其他属性。
+ Mysql的存储引擎MyISAM和InnoDB
  + 在5.5之前，使用的是MyISAM，这种存储虽然性能很好，同时存在比较多好的特性，比如全文索引，压缩和空间函数等，但是由于不支持事物，也就是如果服务宕机的话数据无法恢复。
  + 在5.5之后，使用的是InnoDB存储引擎，这种引擎的优点是支持事物和行级锁和表级锁。
