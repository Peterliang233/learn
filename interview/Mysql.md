### 索引

+ Mysql的几种索引
  + 索引是什么，索引是一种特殊的文件，它们是对数据库里所有记录的引用指针。索引是一种数据结构，数据库的索引，在数据库管理系统是一个排序的结构，以协助快速查询，更新数据库中的数据。索引的实现一般使用B树及其扩展B+树。索引可以提高Mysql的检索速度。
  + 缺点和优点
    + 优点可以加快数据的检索速度。使用索引可以使用优化隐藏器，提高查询的性能
    + 缺点是创建索引和维护索引更加耗费时间，对数据库表格进行增加，删除和修改的时候，索引也需要动态进行修改，会增加增/改/删的效率，同时索引还会占用物理空间。
  + 应用层次来区分有普通索引，唯一索引，复合索引
    + 普通索引：一个索引只包含单列，一个表可以有很多个单列索引
    + 唯一索引：索引的列必须要唯一，可以有空值
    + 复合索引：多个列共同组成一个索引，专门用于组合搜索，效率大于索引合并
    + 聚簇索引：聚簇索引就是叶子节点就是数据节点，叶子节点存储了数据。聚集索引在一个表里面只允许有一个，同时存储的索引记录在物理层面上也是连续的，也就是在我们查找到某一列的数据的时候，我们可以按照索引的连续性很快查找到其他的数据。聚簇索引一般是用主键当作索引，同时在叶子节点存储了我们这行所对应的数据，我们找到了所以，就可以在叶子节点上面找到对应的数据了。
    + 非聚簇索引：叶子节点还是索引节点，不过存储了对应的数据上的指针。非聚集索引不要求连续，他只是在逻辑地址上面的连续，不要求物理地址的连续性。非聚簇索引表示的是主键之外的属性当作索引，和聚簇索引不同的是叶子节点存储的不是数据，而是对应的这一行数据的主键，当我们找到这个主键的时候，我们就需要通过回表的操作从聚簇索引里面找到这条数据。
    + 联合索引：指多个列的索引，减少开销，建立了一个索引，就相当与建立了这个索引集的所有子集索引。覆盖索引，可以直接遍历索引取得数据，减少了很多随机化IO的操作。效率高，索引的列越多，通过索引筛选出的数据就越少，查询的效率也就越高。
  + 索引的划分可以从数据结构上，物理存储上以及逻辑的角度上来进行划分。
  + B树和B+树的区别，B树的将数据分布在树的每个节点之中，B+树是B树的改进版本，B+树的数据都存放到叶子节点上面，而且增加了顺序访问指针，每个叶子节点可以指向相邻的叶子节点。
  + 为什么索引结构默认使用那个B+树，而不是B-树，二叉树，红黑树。
    + B+树的磁盘读写代价更低，B+树的内部节点没有指向关键字的具体信息的指针。内部的节点比B-树更小，如果把所有的同一内部节点的关键字放到同一个磁盘里面，那么盘块所能容纳的关键字的数量也越多，一次性读入内存需要的查找的关键字也是越多。相对IO读写的次数就降低了。
    + 由于B+树的数据只存储在叶子节点里面，分支节点均为索引，方便扫库。只需要扫描一次叶子节点即可。但是B树因为其分支节点同样存储数据，我们要找到具体的数据，就需要进行一次中序遍历来扫，所以B+树更适合区间查询。
    + B-树的所有的值是按照顺序存储的，每个叶子到根节点的距离是相同的，叶子页比较特殊，他的指针指向的是被索引的数据，而不是其他的叶子节点。我们查找数据的时候，首先是在根节点上面进行二分查找，找到对应的叶子节点，然后在叶子节点上面进行二分查找，找到对应的key的data。B-树的索引适合全值匹配，匹配最前缀，匹配范围值等等。
    + 不用哈系表的原因是哈希虽然可以快速定位，但是哈系表没有顺序，IO的复杂度高。只有Memory的存储引擎才显式支持哈希表索引。哈系表只适合等值查询，对于非等值查询就不适用了。而且，如果存在大量的重复的键值的情况，哈系表的冲突碰撞就会很大。
    + 二叉树的高度不均匀，不能自平衡，查找的效率和数据有关。
    + 红黑树的高度随着数据的增大而增大，IO代价高。
  + Mysql的最左前缀原则
    + 最左前缀就是当你创建了联合索引的时候，该索引的任何最左前缀都可用于查询，当你有了一个联合索引，你就有了该索引的所有前缀。最左前缀原则可以是最左N个字段，或者是字符串索引的最左的M个字符。
  + Mysql的最左匹配原则
    + 在mysql建立联合索引的时候，当我们在查询的时候，只有在左边的索引都得到匹配之后，才可以匹配当前的索引。
  + 前缀索引，索引的字段很长的时候，这样既占存储空间，又不利于维护，所以可以把很长的字段的前面的公共部分作为一个索引。
+ 哪些mysql的操作会让索引失效
  + or,多列索引,like，where中使用!=,><,where后面使用表达式，where后面使用not in,is not null等

### 日志

+ bin_log,redo_log,undo_log三者的区别
  + bin_log是逻辑日志，Mysql_server实现的，属于是server层的数据，是一个逻辑日志，类似与存储的是SQL脚本，不会覆盖之前的版本。可以用于主从复制的搭建。同时还可以用于数据的恢复。
  + redo_log是物理日志，是是存储引擎特有的，是一个物理日志，记录的是在某一个数据页面进行了什么修改。这个文件是一个循环写入的。主要用于服务器宕机和介质故障的数据恢复使用。redo_log写磁盘的方法是顺序读写的操作，很好的利用了磁盘的特性，所以读写特别快。同时它是一种覆盖写的方法，所以日志不会逐渐增长。redo_log包含buffer层和log层，分别记录了我们持久化的操作和我们物理页的修改信息。表现的特性是持久性，当服务宕机的时候，我们可以通过redo_log来恢复我们还没有落盘的数据，体现了数据的持久性。
  + undo_log是逻辑日志，提供了多个版本之间的并行控制和回滚。我们通过记录每次执行某种操作之前的数据，当这个事务失败的时候，我们提供了事务的回滚操作。
+ bin_log有几种录入格式
  + statement模式，记录单元为语句，每一条sql造成的影响都会被记录，由于sql执行是有上下文的，所以这些信息就会被记录下来。
  + row模式，记录单元为某一行的改动，由于改动量比较大的时候，就会造成日志过大。
  + mixed模式，是一种折中的方案，普通的操作使用statement，当无法statement的时候使用row。


### 事务

+ MVCC
  + 多版本并发控制。是数据库管理系统一种常见的并发控制，我们知道并发控制常用的是锁。当线程要对一个共享资源进行操作的时候，加锁是一种比较粗暴的方法。这种锁是一种悲观的实现。这会阻塞其它事务，影响数据库的性能。
    + 悲观锁。当一个线程需要对共享资源进行操作的时候，需要对共享资源加锁。这种锁会阻塞其他事务。
    + 乐观锁。当一个线程需要对一个共享资源进行操作的时候，乐观锁通过一个版本控制号，如果操作完成后通过这个版本号判断在该线程操作的过程中是否有其他线程已经对该共享资源进行了操作，那么通知操作失败。mvcc就是一种乐观锁的实现形式。
  + mvcc的两种读形式
    + 快照读，读取的只是当前事务的可见版本。比如简单的select操作。
    + 当前读。读取的是当前的版本，比如特殊的读操作，更新/插入/删除操作。
  + 实现原理
    + Mysql在建表的时候会创建三个隐藏的字段来实现并发版本控制。
    + 在Mysql创建表格的时候，会创建一下三个隐藏字段。
      + RowID，如果在创建表格的时候没有制定主键，那么就会自动使用这个RowID创建一个聚簇索引。
      + DB_TRX_ID，最近修改该记录的事务ID
      + DB_ROLL_PTR,回滚指针，记录上一个版本
    + MVCC通过使用事务ID，回滚指针和删除标识和undo log和可见性算法实现了版本并发控制。
    + read-view，当执行快照读的时候，会创建一个read-view，这个read-view其实只是三个字段。alive_trx_list，记录生成此刻系统中正在活跃的事务id，可以看作是一个数组。up_limit_id，记录上面的alive_trx_list的最小的事务id，low_limint_id，在read-view生成时刻，目前已经出现的事务ID+1
    + 可见性算法
      + 当生成read-view时候，我们会拿取DB_TRX_ID和这个read-view的up_limit_id进行比较。如果小于，那么就说明当前事务可见这条记录。否则，执行下一步。如果事务ID小于当前活跃的事务id里面的最小的id，那么说明我们这个查询操作是在很早之前就开始了，说明此时读取的数据对于现在来说都是可见的。
      + 判断这条记录的DB_TRX_ID是否大于等于low_limit_id,如果大于等于，说明此事务无法看见这条记录，不然就执行下一步。如果此时的事务id大于当前所有的事务id，那么说明我们得到的所有的事务id都在这个事务id之后，此时读取的还不是确定的。所以这个是不可见的。
      + 判断记录的这条DB_TRX_ID，是否在活跃数组里面，如果在说明这条记录还没有提交，当前操作是事务是不可见的，不在说明已经提交了所以是可见的。如果进行快照读的时候，这个事务id还在当前的活跃的事务里面，那么说明此时这些事务还没有提交，保存到磁盘里面，所以这是不可见的。
  
+ 并发事务带来的问题

  + 更新丢失，如果存在多个事务对同一行进行修改操作，由于事务之间是相互不感知的，所以可能会造成本事务修改其他事务的数据的情况。
  + 脏读，一个事务读取了另一个数据的未提交的数据，也就是读取了脏数据，但是在这个事务提交之前，数据就已经不一致了。脏读可以理解为事务和事务直接的。
  + 幻读，一个事务按照相同的条件多次查询，但是由于其他事务插入了新的满足条件的数据，然后造成了读取的数据不一致的情况。幻读可以理解为事物与结果集之间的。
  + 不可重复读，就是数据在读取的某一条数据之后，再次读取的时候发现其它事务已经把这条数据删除了，造成了不可重复读的情况。

+ mysql的隔离级别（低级别的事务一般拥有更高的并发处理，并且拥有更低的系统开销）

  + 读未提交的内容，这种一般会造成脏读。

  + 读取提交的内容，这是大多数数据库系统的默认隔离级别。这种一般会造成不可重复读。
  + 可重复读，这个是mysql的默认隔离级别。他保证了一个事务的多个实例在并发读取数据的时候，会看到同样的行，这种一般会造成幻读的情况。但是mysql可以通过mvcc来解决这种情况
  + 可串行化，这是mysql的最高隔离级别，通过强制事务的排序，从而解决幻读的问题。

+ 乐观锁的实现
  + 版本号控制。通过设置数据被修改的次数，当数据被修改的时候，这个字段就会加1。所以，我们只需要比较读之前和读取之后的版本号就可以判断是否满足乐观锁的实现了。
  + $CAS$算法。比较并且交换。是一种有名的无锁算法。无锁编程。即不用锁的情况下实现多线程之间的变量同步。所以也叫做非阻塞同步。CAS算法涉及到三个操作数。
    + 需要读写的内存值V,这个可以理解为初始的版本
    + 进行比较的值A，这里可以理解为读取之后的版本
    + 拟写入的新值B
  + 当且仅当V的值为A的时候（如果两个版本都是一样的，那么说明这个值没有被其它线程访问），$CAS$通过原子操作用新值B进行更新V的值。否则不会执行任何操作。一般情况下，这是一个自旋的操作，即不断的尝试。
  + cas算法会有一个ABA问题，就是你这个线程读取的时候得到一个值A，然后另一个线程进行修改得到一个值B，然后这个线程又将这个值修改成了A，那么你读取的内存值和预期值其实还是一样的。但是其实这两个变量已经不是同一个变量了。
  + ABA问题出现的原因是你的变量变化是可以出现环形的，为了解决这个问题，我们可以使用在单个方向进行变化的进行处理，比如一个自增的主键ID。同时我们可以增加一个版本信息和时间戳进行解决。
+ 悲观锁的实现
  + 悲观锁一把是使用信号量实现的。在数据库里面使用的是行级锁来进行处理。
+ 谈谈事务
  + 事务的实现主要依赖于两个log，一个是redo-log，另一个是undo-log。每次事务都会在记录的数据修改前进行数据的undo-log，进行上一个版本的数据的备份。成功修改之后数据放入redo-log,提交成功之后则使用redo-log存储进磁盘空间里面。失败则使用undo-log则恢复到事务修改之前的数据。

### 集群

+ Mysql的主从复制主要用到的是binlog来保持数据的一致性。
+ 集群结点分为管理节点，数据节点和SQL节点。
  + 管理节点：主要是管理数据节点和SQL节点，还有集群配置文件和集群日志等。
  + 数据节点：数据节点用于存储数据，使用内存数据，保存进数据节点的数据会自动复制并且存储到其他数据节点上面。
  + SQL节点：可以理解为应用程序和数据节点的桥梁，应用程序不能直接访问数据节点，只能先访问SQL节点，然后SQL节点再访问数据节点来查询数据。

### 性能调优

+ 通过explian来查询sql执行的过程，然后进行调优。
+ 或者是在一些细节上进行处理。比如不要怎么做，要怎么做等等。
+ 加索引。
+ 分表分库等等。

### 分区

+ 当单表查询到一定的程度之后，Mysql单表的数量级达到一定的程度之后，查询就会很慢，那么针对这种情况，我们能想到的就是分表分库的操作了。
+ 分区类型
  + Range，指定范围内分区。
  + List，离散值分区。
  + Hash，计算单个列的哈希值，然后指定分区数量，进行分区。
  + Key，计算单个或者是多个列的Hash值，然后指定分区的数量，进行分区。

### 其他

+ 数据库的三大范式
  + 第一范式，数据库的每列的数据不可分解。
  + 第二范式，在满足第一范式的基础上，非主键属性需要完全依赖主键，不可以部分依赖主键。
  + 第三范式，在满足第一范式和第二范式的基础上，非主键属性不能依赖于主键之外的其他属性。
  
+ Mysql的存储引擎MyISAM和InnoDB

  + 数据库使用存储引擎进行创建，查询，更新和删除的操作。不同的存储引擎提供了不同的存储机制，索引技巧，锁定水平等功能。
+ 在5.5之前，使用的是MyISAM，这种存储虽然性能很好，同时存在比较多好的特性，比如全文索引，压缩和空间函数等，但是由于不支持事物，也就是如果服务宕机的话数据无法恢复。
  + 在5.5之后，使用的是InnoDB存储引擎，这种引擎的优点是支持事物和行级锁和表级锁。
+ InnoDB支持主键，外键等，MyISAM不支持。
  + InnoDB有更多的内存存储，MyISAM可以被压缩。

+ 主键使用自增ID还是使用UUID？
	+ 我们需要考虑两个方面，一个是性能的影响，一个是存储空间的大小，一般都不推荐使用UUID作为主键。使用UUID不能确保插入的数据是有效的，有可能涉及数据的挪动和触发数据的分裂。自增的ID作为主键插入数据都是追加的操作，不会设计数据的移动以及数据页的分裂。

    
