### 基础知识

+ 静态方法和非静态变量？

  + 静态方法是属于类的，在类被加载的时候就会被分配内存，但是非静态成员是属于实例对象的，只有在对象实例化之后才存在，需要通过类的实例化之后的对象去访问。
  + 静态方法是属于某一个类的，而不是属于某一个对象实例的。
  
+ 静态方法和实例方法

  + 在外部调用静态方法的时候，可以通过类名.静态方法或者是对象名.方法来调用，而实例方法之可以通过对象.方法来进行调用。
  + 静态方法在类里面只可以访问静态变量，而实例的方法没有这个限制。
  
+ 重载和重写的区别

  + 重载是对于同一个方法根据输入的数据的不同，进行不同的处理。
  + 重写就是当子类继承了父类的方法的时候，输入的数据一样，但是要作出有区别于父类的响应，就是要覆盖父类。重写发生在运行期，方法的重写需要准询两同两小一大的原则，两同就是函数名和参数都要相同，两小就是返回类型和抛出的错误的类型需要比父类更小，一大就是对数据的控制需要比父类更大。
  
+ ==和equal的区别

  + 如果是基本的数据类型，那么就是比较值。
  + 如果是包装类型，比较的就是内存地址。
  + equal函数的实现，默认比较的是两个对象的内存地址。当然也可以自己重写equal函数自己定义比较的标准。但是注意在我们重写equal的时候必须要重写hashcode，这样才是符合逻辑的，因为相同的对象的hash值必须要一样。不然到时候使用hashmap的时候会出现问题。

  ```java
     // 自定义比较函数
  	@Override
      public boolean equals(Object obj) {
          if (this == obj) return true;
          if (!(obj instanceof Person)) return false;
          Person person = (Person) obj;
          return person.name != name;
      }
  	// 默认equal函数
  	public boolean equals(Object obj) {
          return (this == obj);
      }
  ```

  + 当然，还有涉及到装箱和拆箱的操作。将基本数据类型包装成包装类就是装箱的操作，反过来就是拆箱的操作。对于基本的数据类型，往往有对象的包装类，如果一个是包装类，一个是基本的数据类型，他们之间比较一般是相等的，比较的是值。

  ```java
  // 默认的equal函数
  public boolean equals(Object obj) {
          if (obj instanceof Integer) {
              return value == ((Integer)obj).intValue();
          }
          return false;
   }
  
          Integer i = 10; // Integer i = Integer.valueof(10);
          int j = i; // int j = i.intvalue();
          System.out.println(i==j); // true
  ```

  + 同时，这里需要注意的是基本数据类型的局部变量存放的地方是JAVA虚拟机栈里面的局部变量表里面，基本的数据类型的成员变量存放的地方是JAVA虚拟机的堆中，其余的对象类型，基本存放的都是堆。
  + Byte，Short，Int,Long都实现了常量池技术，也就是都创建了默认的缓存，在定义一个新的对象的时候，会从常量池缓存里面取数。如果使用等号的话比较的是值。

+ 基本的数据类型和对应的包装类

  + byte，一个字节
  + short，两个字节
  + int，四个字节
  + long，八个字节
  + char，一个字节
  + float，四个字节
  + double，八个字节
  + boolean

  + 对应的包装类就是把他们的首字母大写实现即可。
  + 区别：如果不赋值的话基本的数据类型就是对应的零值，包装类就是null。
  + 基本的数据类型和包装类之间的转换涉及到一个装箱和拆箱的过程。

+ 接口和抽象类有什么共同点和区别？

  + 共同点
    + 都不能被实例化。
    + 都可以包含抽象方法
    + 都有默认的实现方法。
  + 区别
    + 接口主要是对类的行为进行约束，你实现了某一个接口就具有了对应的行为。对于抽象类，更加强调的是一种所属关系。这里我理解的是既然是抽象类，那么就说明还不能根据某些特性将其具体化，所以这些特性应该是公共的，难以区分的。接口呢？应该是代表这某一类所特有的东西。
    + 一个类只能继承一个类，但是可以实现多个接口。
    + 接口中的成员变量只能是public static final 类型，不能被修改但是必须有初始值。抽象类的成员变量默认是default，可以在子类中被重新定义，也可以被重新赋值。

+ 深拷贝，浅拷贝和引用拷贝的区别

  + 浅拷贝会在堆上面创建一个新的对象，但是如果存在引用类型的话。会直接执行这个引用对象，不会直接进行创建一个新的，所以其实底层地址还是用的是同一块。
  + 深拷贝，深拷贝会完全复制整个对象，包含这个对象的所有内部对象。也就是完完全全复制出一份新的对象出来，内存地址完全不一样。
  + 引用拷贝就是两个不同的引用指向了同一个对象。

+ String,StringBuffer和StringBuilder的区别
  + String中的对象是不变的，因为底层是采用的是final关键字来修饰字符数组来表示这个字符串。可以认为是线程安全的，StringBuffer对方法或者是调用的方法加了同步锁，所以是线程安全的，StringBuilder不是线程安全的。
  + String类型进行改变的时候，都会生成一个新的String对象，然后指针指向新的对象，StringBuffer每次是对对象本身操作，但是StringBuilder确比StringBuffer的性能更好，但是却有非线程安全的隐患。

+ 字符串常量池
  + JVM为了提升性能和减少内存消耗针对字符串专门开辟的一块区域，主要是为了避免字符串的重复创建。当我们创建一个String对象的时候，如果常量池里面有这个常量，那么我们只创建一次，否则就创建两次。

+ 泛型
  + Java的泛型是伪泛型，在java运行期间，所有的泛型信息都会被替换掉，这也就是所谓的类型擦除。
  + 泛型类。
  
  ```java
  
  public class Person<T>{
      private T key;
      
      public Person(T key) {
          this.key=key;
      }
  
      public T getKey(){
          return this.key;
      }
  
      public static void main(String[] args){
          Person person = new Person<String>("name");
          System.out.println(person.getKey());
          Person person2 = new Person<Integer>(123);
          System.out.println(person2.getKey());
      }
  }
  ```
  
  + 泛型接口。
  + 泛型方法。
  + 常见的使用的符号是K，V，T，？，E
  
+ 反射
  + 我们通过反射，可以或得任何一个类的属性和方法。同时你还可以调用这些方法。
  + 反射的优点：可以使代码更加灵活，为各种框架提供了开箱即用的功能提供了便利。缺点：让我们在程序运行的时候具有分析类的作用，同时增加了安全问题，可能会无视范型参数的安全性校验，而且性能也稍微差了一点。
  + 应用
    + 在一些框架中，比如springboot/spring等，都使用了大量的代理机制。还有比如一些注解，也用到了反射的机制。
  + 获取class对象的四种方法
    + 直接`Person.class`得到
    + 通过class提供的`class.forName("类的路径")`得到
    + 通过对象实例`person.getClass()`得到
    + 通过类加载器`ClassLoader.loadClass("类的路径")`得到
  
+ 注解
  
  + Annotation是一种特殊的注释，用于修饰类，方法和变量。注解只有在被解析之后才会生效使用
    + 编译期直接扫描，编译器在编译期间就对代码进行了扫描并且进行处理，比如override。
    + 运行期间通过反射处理。就比如一些框架自带的注解同时通过在执行期间的反射来进行处理的。
  
+ 异常
  + Exception和Error都是继承了父亲类Throwable这个类。Exception值的是程序可以处理的异常，同时这个异常可以被捕获，这个异常也可以分为可处理和不可处理的异常。Error是程序无法处理的错误。不建议通过catch捕获，这种情况一般会造成线程的停止。常见的受检查的异常有IO相关的异常，这类异常会造成无法编译的错误。不受检查的异常有数组越界，算术异常，类型转换异常等等。

+ 序列化和反序列化
  + 在进行网络传输的时候，我们常常需要将我们的java对象转化为二进制数据流传输，这个就是序列化，反序列化就是将二进制的数据流转化为我们创建的java对象。
  + 序列化的作用是通过网络传输对象或者是将对象存储到文件系统，数据库或者内存中。
  + 如果不想让某一些变量序列化，可以加关键字transient，transient只能用来修饰变量，不能用来修饰方法或者是类。transient进行反序列化的时候会将变量设置为对应的默认值。static不属于任何对象，不会进行序列化操作。

+ 代理模式

  + 代理模式的主要功能是拓展目标对象的功能。比如在目标对象的某一个方法执行前后你可以自己定义一些操作。
  + 静态代理
    + 静态代理就是在编辑阶段将接口，实现类，代理类这些都变成一个一个实际的class文件。
    + 实现步骤
      + 定义一个接口及其实现类
      + 创建一个代理类实现这个接口
      + 将目标对象注入代理类中，然后在代理类的对应的方法调用目标类中对应的方法。这样的话，我们可以通过代理类屏蔽目标对象的访问，同时也可以在目标函数执行前后自定义一些函数。
  + 动态代理
    + 动态代理在运行时动态生成类字节码，并且加载到JVM里面。
    + 动态代理分为JDK 动态代理和CGLIB动态代理。JDK 动态代理只能实现一个实现了接口的类。主要的过程就是重写一个InvocationHandler函数。CGLIB动态代理是通过生成一个代理类的子类来拦截被代理类的方法调用。

+ HashMap的底层实现
  + HashMap的底层是数组加链表来实现的，结合起来就是链表散列。在创建一个链表数组的时候，每个位置都是一个链表，如果遇到哈系冲突，那么就会把冲突的节点加到链表中，当链表的长度超过阈值的时候，就会树化，转化为一个红黑树存储，如果小于的话，就会链化，再次转化为一个链表的形式
  + 卸载：该类的Class对象被GC，需要保证该类的所有的实例对象都被GC，同时该类没有被其他任何对象引用，该类的类加载器实例被GC。
  
+ 集合

  + java的集合是由两大接口派生而来的，一个是Collection接口。主要用来存放单一元素，还有一个map接口，用来存放键值对。Collection派生出了三个接口，分别是List，Set和Queue。
  + list
    + ArrayList是数组实现。
    + Vector是数组实现。
    + LinkList是双向链表实现。
  + Set
    + HashSet基于Hashmap实现，底层采用的是HashMap来存储元素。
    + LinkedHashSet：继承了HashSet，内部是LinkedHashMap来实现的。
    + TreeSet：内部是红黑树实现。
  + Queue
    + Priority_queue利用数组来实现了二叉堆。
    + ArrayQueue：采用的是数组+双指针实现。
  + map
    + 在JDK1.8之前，采用的是HashMap来实现的，如果遇到哈希冲突就会使用拉链法来解决冲突。JDK1.8之后，在解决哈希冲突的时候有了比较大的变化，当链表的长度超过域值的时候，链表会转化为一棵树，翻过来树会转化一个一个链表。HashMap不是线程安全的，ConcurrentHashMap是线程安全的。
  + Comparable和Comparator的区别
    + comparable接口实际上是出自java.lang包，它包含一个CompareTo方法来排序。
    + comparator接口实际上是出自java.util包，他有一个compare函数来进行排序。
  + HashMap的底层实现
    + HashMap的底层采用的是数据加链表的方法来实现的，在我们插入一个新的元素到集合里面的时候，会先通过hashCode进行哈系，然后利用扰动函数计算出是在哪个桶里面。然后如果对应的位置的hash值是一样的，那么我们就会进行覆盖，如果存在不同的hash值，那么我们就会放到这个桶里面，如果是链表的话，就会插入到链表的最后面，否则就是插入到红黑树上面，注意这里需要进行红黑树的调整，但是时间复杂度也是可以接受的。注意当单个链表的长度超过了8而且总的数组的长度超过了64的时候才会触发树化。
    + 主要的几个函数是`put`，`get`，和`resize`
    + `put`方法
      + 先计算出相关的hash值找到对应的桶的位置，如果是相等的话，那么我们就可以对这个位置的元素进行覆盖，否则就是插入到这个桶的位置。
    + `get方法`
      + 还是先得到hash值，如果桶里面只有一个元素，那么就直接返回，否则就从红黑树里面或者是链表里面返回第一个节点（first节点）。
    + `resize`方法
      + 当哈系冲突非常严重的时候，会出发一次重新的hash分配，并且会遍历hash表中的所有的元素，这是非常耗时的，所以我们需要尽量避免。主要的办法是增大数组的长度，对于新得到的哈希值，将其从原来的桶里面分到新的桶里面即可。
  + ConcurrentHashMap
    + JDK 1.7版本（Segment数组+HashEntry数组+链表实现）
    + 前面我们知道，HashMap不是线程安全的，而ConcurrentHashMap确实线程安全的。他使用的频率也是非常高的。ConcurrentHashMap的存储结构分为很多个Segment组合。而每个段又是类似于HashMap的结构，所以每个HashMap的内部可以进行单独扩容，但是这个段的数量一旦进行初始化就不能被扩容。默认的个数是16,所以也就默认最多支持16个多线程并发使用。（其实这里很好里面，我们把每个线程的作用空间进行了单独的切分，那么如果有并发的情况，每个线程之间都是互不干扰的，也就实现了并发安全）
    + `put`
      + 找到一个空的段，然后进行初始化，最后利用CSP算法检查是否有其他线程在这个过程中对这个段进行了操作，如果没有，那么执行put操作。找到空的段的过程是自旋的操作。
    + `get`
      + get操作也是先找到key存放的位置，然后遍历指定的位置找到相同key的value值，这里也会涉及到一个value值。
    + JDK 1.8 版本（Node数组+链表/红黑树实现）
      + `put`
        + 首先根据hash值确定在哪个数组桶里面，如果没有这个桶，那么就采用自旋+CAS来初始化一个桶，如果存在桶，但是桶里面只有一个节点，那么就不加锁,直接CAS插入。否则的话就利用Synchronized锁对对应的节点进行加锁。
      + 使用的是Syncchronized锁和CAS机制来实现的

### 并发

+ Java的程序计数器采用的是多个线程共享进程的堆和方法区，但是每个线程都有自己的程序计数器，虚拟机栈和本地方法栈，这些都是私有的。

+ 程序计数器
  + 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码流程的控制。
  + 在多线程的情况下，涉及到不同的进程之间的切换，所以我们需要利用程序计数器来记录当前进程的执行的位置。
  
+ 虚拟机栈
  + 每个java方法在执行的时候都会创建一个栈帧用来存储局部变量表，操作数栈，常量池引用等信息，从方法调用直到完成，对应的就是虚拟机栈的入栈和出栈的过程。
  
+ 本地方法栈
  + 和虚拟机栈的作用一样，虚拟机栈是为了执行java方法调用服务，而本地方法栈是为了虚拟机可以使用到native的方法服务。
  
+ Sleep()和wait()的区别
  + Sleep不会释放所，wait会释放锁。
  + 两者都可以让线程暂停。
  + wait方法通常用户线程之间的通信，sleep方法通常被用作暂停执行。
  + wait方法被调用后，线程不会自动苏醒，需要调用notify方法来唤醒这个线程，sleep一旦到达了时间点，就会自动苏醒。
  
+ 为什么调用start的方法会运行run方法，而不是直接调用run方法
  + 当new一个新的线程的时候，调用start方法会启动一个线程并且使线程进入就绪状态，当分配到时间片之后就可以开始运行了。会运行一个线程开始运行的准备工作。但是如果直接调用run方法，会被认为是一个main线程下面的普通的方法去执行，不会在线程中使用它。
  
+ Synchorized关键字用来解决多个线程之间的访问资源的同步性的问题，保证修饰的代码或者是方法在某一个时刻只有一个线程在运行。这是一个同步锁。

+ 如何使用Synchorized
  + 直接放大某一个方法或者函数的前面，表示在进入这个代码块的时候只能有一个线程在运行。
  + 修饰静态方法
  + 修饰代码块

+ 实现一个双检测单例模式

  ```java
      private volatile static Person uPerson;
  
      private Person() {
  
      }
  
      public static Person getUPerson() {
          if (uPerson == null) {
              synchronized (Person.class) {
                  if (uPerson == null) {
                      uPerson = new Person();
                  }
              }
          }
          return uPerson;
      }
  ```

  + 上面为什么要套两层呢？因为我们java在运行的时候有一个指令重排机制，可能会打乱原来的执行的顺序，所以我们在加锁之后还需要再进行一次验证是否为null，然后才可以进行new一个新的实例的操作。
  + 在创建一个新的实例的时候，一般是先分配内存地址空间，然后再进行初始化，最后执行分配的地址空间即可。
  + 这里我们使用volatile是为了禁止JVM的指令重排的机制。

+ synchornized底层原理

  + 同步语句块的时候，使用了monitorenter和monitorexit指令，分别记录的是同步代码开始的位置和同步代码结束的位置。在执行monitorenter的时候，会尝试获取对象的锁，如果锁的计数器为0,则表示可以被获取，当执行monitorexit指令的时候才会将锁的计数器恢复。
  + 同步方法的时候，没有monitor指令，取而代之的是ACC_SYNCHRONIZED指令。

+ JDK 1.6之后Synchornized的实现优化

  + 优化后的级别分为无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态。竞争激烈的程序从高到低。锁只可以不断升级，不可以降级。

+ volatile和synchronized的区别和联系

  + volatile关键字是修饰变量的，而后者使用来修饰函数和方法的。他们之间是互补的。
  + volatile保证了数据的可见行，而没有保证原子性，后者两者都保证了。
  + volatile用户解决多个线程之间的数据可见行性，而后者保证了多个线程访问资源的同步性。

+ 如果我们想让没一个线程都有自己的专属的本地变量。ThreadLocal可以让每个线程都绑定自己的值。具体实现大致是通过实现了两个定制化的HashMap来实现的，默认的情况下都是null，存取变量也都是通过从hashmap里面进行处理。但是注意的是这个可能会存在内存泄漏问题，建议在使用完Thread的时候自行调用remove（）。

+ 线程池
  + 使用原因
    + 降低资源的消耗，通过重复利用已经创建的线程来降低线程的创建和消耗造成的消耗。
    + 提高响应速度，当任务到达的时候，任务可以不需要等待线程创建就能立即执行。
    + 提高线程的客观理性。线程资源的稀缺，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
  
+ execute和submit的区别
  + execute方法用于提交不需要返回值的任务，所以无法判断线程池是否成功与否。
  + submit方法用于提交需要返回值的任务，线程池会返回一个Feacture类型的对象，可以通过这个判断任务之否执行成功。
  
+ ThreadPoolExecutor饱和策略
  + 如果当前同时运行的线程的数量大于设置的最大线程数量的时候并且队列已经放满了任务，那么就会执行一下策略。
    + 抛出错误拒绝处理
    + 调用自己的线程运行任务。
    + 不处理任务，直接进行丢弃。
    + 丢弃最早未处理的任务请求。
  
+ 线程池execute的方法
  
  + 这里有三个比较核心的参数，分别是最大核心线程数量，最大运行线程数量和等待队列。
  + 首先判断线程池里面的任务的数量是否小于coreSize，小于的话就创建一个线程来执行任务。
  + 如果当前执行的任务的数量大于等于corePoolSize，会判断线程池是否是running状态，只有是running状态才会加入任务队列里面。
  + 如果任务队列已经满了的话会判断线程池里面是否已经满了，如果没有满的话就会创建一个新的线程，否则就执行对应的策略。
  
+ AQS（抽象队列同步模型）
  + 是一个构建锁和同步器的框架。核心思想就是如果被请求的资源是空闲的，那么就将当前请求资源的线程设置为有效的工作线程。并且将共享资源设置为有效的状态。如果被请求的资源是被占用的状态，就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制就是AQS利用CHL实现的。CHL是一个双向队列，将每个请求共享资源的线程封装成一个结点。
  + 对资源的共享方式
    + 独占，只能有一个线程去执行，可以分为公平和非公平，公平就是按照队列的顺序去执行，非公平就是无视队列的顺序去抢夺锁。非公平锁利用CAS实现。公平锁和非公平锁的区别是公平锁会先判断CHL里面是否有等待的线程，如果有的话就不去CAS抢锁。
    + 共享，可以多个线程同时去使用。

### JVM

+ java虚拟机在执行java程序的时候将管理的内存分为若干个不同的区域，分别是公共的区域堆和方法区。还有就是各个线程之间内部私有的本地方法栈，虚拟机栈和程序计数器。
  + 程序计数器控制了程序的流程，以及线程之间的来回切换记录线程执行的位置。
  + 方法的调用的数据一般都是通过数据来进行传输的，每一次的方法的调用都会对应数据的压栈和出栈操作。每个栈都由一个一个栈帧组成，每个栈帧都有局部变量表，操作数栈，动态链接和方法返回地址。局部变量表用来存放编译期的可知的各种数据，操作数栈一般是记录的一些中间变量和中间结果。动态链接主要是用于一个方法调用其他方法，java程序在被编译成字节码的时候，所有的变量的方法引用都作为符号引用保存在class文件里面，当我们一个方法要调用其他方法的时候，就需要得到其在内存里面的直接引用，而动态链接就是将对应方法的符号引用转化为内存地址里面的直接引用的。
  + 本地方法栈是为了调用本地的native的方法而服务的。
  + 堆是虚拟机所管理的内存里面最大的一块内存了，这是所有的线程都共享的一块内存，次区域存放所有内存对象的实例，几乎所有的对象实例以及数组都存在这块内存里面。这个也是java的GC所主要进行内存回收的一块区域。同时堆上面的内存有些情况下可能会逃逸到栈里面。这个时候就可能会造成内存泄漏问题。在JDK1.7之前，堆通常被分为新生代，老生代和永久代。在JDK1.8之后，方法区被替换成了元空间和永久代。
+ 为什么需要将永久代替换成元空间呢？
  + 整个永久代有一个JVM本身设置的固定大小的上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍然可能溢出，但是可能性更小。
  + 而且元空间的大小不是固定的，这样可以加载更多的类。
+ Java的类的加载的过程
  + 加载：通过类的全名得到此类的二进制的字节流。将字节流代表的静态存储结构转化为方法区的运行数据结构。在内存中生成一个代表该类的class对象，作为方法区的这些数据的访问入口。
  + 验证：验证类的文件格式，字节码，元数据和符号引用等等。
  + 准备：正式为类变量设置内存并且设置类变量的过程。
  + 解析：虚拟机将常量池里面的符号引用替换为直接引用的过程，主要针对类或者接口，字段，方法，接口方法等等。
  + 初始化：类加载的最后一步。这一步中JVM才开始真正执行类中的java程序代码。
+ java对象的创建
  + 执行类加载检查，当遇到一个new指令的时候，我们首先去检查这个指令的参数是否在常量池里面或者是否可以定位到这个类的引用，并且检查这个类是否已经加载过了，如果没有的话就执行类加载的过程。
  + 分配内存，当类加载检查通过之后，接下来虚拟机将为新生内存分配对象，分配的方式有指针碰撞和空闲列表两种方法，选择哪种方法由java堆是否规整决定。
    + 指针碰撞：指针碰撞使用于内存规整的内存，大概就是将内存分为已经分配和未分配，分为两边，中间用一个指针进行维护，分配内存的时候只需要往没有分配的一个方向移动就行了。
    + 空闲列表：堆内存不规整的情况。虚拟机维护一个列表，该列表会记录哪些内存块是可用的，然后需要分配的时候找到一块足够大的内存分给对应的对象即可，最后更新链表。
    + 内存并发分配问题。虚拟机用CAS+失败重拾和TLAB两种方法来确保线程安全。CAS就是采用一个乐观锁的机制，如果遇到了冲突那么就进行重试，直到成功位置。TLAB是先为每个内存分配一块内存，JVM在给线程分配的时候，会先在TLAB上面进行分配，然后TLAB的内存不够用的时候，才会执行CAS+重试的机制继续申请内存。
  + 初始化零值，为每个变量设置默认的零值。
  + 设置对象头。虚拟机要对对象进行必要的设置，比如记录类是哪个实例的，如何找到类的元数据信息，对象的哈系码等等。
  + 执行init。
+ 对象的内存布局，对象在内存布局里面分为三个区域，对象头，实例数据和对齐填充。
+ 对象的访问定位
  + 建立好了对象，但是我们想要用的时候怎么在内存里面找到这些对象呢？java通过堆上面的reference来操作堆上面的对象。目前使用的方式主要有使用句柄和指针两种方法。
  + 句柄：使用句柄的话，java需要在堆上面开辟一个内存用见用来存储句柄，reference存储的是对象的地址，而句柄里面存储的是对象的视力数据以及各自的内存地址信息。
  + 直接指针：使用直接指针访问，那么java对象堆上面就必须要考虑到如何设置访问类型的相关信息。而reference存放的就是对象的内存地址。
  + 使用句柄的最大的好处就是对象被移动的时候只需要改变实例数据的引用，而使用指针的好处就是速度快。
+ 垃圾回收算法
  + 分代收集法。我们将堆内存分为新生代和老年代。这样我们就可以根据各自的特点来选择合适的垃圾回收算法。
  + java的对象的内存优先分配到eden分区上面。大对象一般都会分配到老年代，因为存在一个担保机制，内存分为新生代和老年代。我们首先会将对象分配到新生代上面去，如果空间不够的话就会利用担保机制先将部分分配到老年代，直接分配大的对象到老年代可以避免因为担保机制带来的内存复制。
  + 对于hotSpot VM的实现来说，垃圾回收一般分为两大类，部分收集和全部收集，部分收集也分为新生代收集，老年代收集和混合收集。
  + 空间分配担保是为了在执行mirror GC之前老年代本身的内存还可以容纳新生代的所有的剩余对象。
  + 如何判断对象是否已经死亡
    + 引用计数法。如果对象被引用一次，那么计数加1,否则就减1。但是这里会有循环引用的问题。
    + 可达性分析。以GC ROOT为起点，从当前的节点往下面开始进行搜索，我们从这些节点开始向下进行搜索，节点所走过的路径被称为引用链。当一个对象到GC ROOT没有任何路径的时候，就可以说明这个对象已经死亡了。但是GC ROOT如何被选取呢？虚拟机栈里面引用的对象，本地方法栈引用的对象。方法区中的静态属性引用的对象。方法区中常量引用的对象，所有被同步锁持有的对象。
  + 对象被回收，就代表对象一定会被回收吗？
    + 一个对象一次GC之后会进入缓刑阶段，只有被标记两次之后才会执行清除的操作。在这个期间如果和引用链的某一个对象产生了关联，那么就不会执行GC操作。
+ 引用
  + 强引用，强引用是必不可少的对象，即使内存不够也不会进行清除。
  + 软引用，软引用是可有可无的，只有在内存空间不够的时候才会执行清除。
  + 弱引用，弱引用一旦执行GC的操作，就会被清除。
  + 虚引用，虚引用并不会决定一个对象的存活时间。在任何时候都可能被垃圾回收。

+ 如何判断一个无用的类
  + 该类的所有实例都被回收，在java堆中不存在该类的任何实例。
  + 加载该类的ClassLoader已经被回收。
  + 该类对应的java.lang.class没有在任何地方被引用，无法在任何地方可以反射到这个类上面。

+ 垃圾回收算法
  + 标记-清除法，对不需要进行回收的对象进行标记。最后回收没有被标记的对象。这样可能造成大量的内存碎片。消息不行。
  + 标记-复制法。将内存分为两块，只用其中的一边，当进行标记-清除的时候，将不需要回收的对象移动到另一半未用的内存空间里面。然后在把使用的空间一次性清除。
  + 标记-整理法。在标记的基础上，将所有可存活的对象移动到一端。
  + 分代收集法。分为i新生代和老生代。新生代可以gc次数比较频繁可以采用标记-复制的方法，老生代可以采用标记-清除的方法。

+ 垃圾回收器
  + 是垃圾回收的具体实现。
  + Serial，串行，stop the world，单线程回收，效率低。
  + ParNew，多线程版本。新生代采用的是标记-复制的方法，老生代采用的标记-整理的方法。
  + Parallel Scavenge，JDK1.8默认的收集器，吞吐量比较好。
  + Serial old，可以作为CMS的备用方案。
  + Parallel old，多线程的情况。
  + CMS收集器，CMS是一种以获取最短回收停顿时间为目标的收集器。可以让垃圾回收线程和用户线程可以同时运行。是一种标记-清除算法。
    + 初始标记，暂停所有的其他线程，然后记录直接和root相连的对象。
    + 并发标记，同时开启gc和其他用户线程，用一个闭包去记录所有的可达对象。这个期间可能还有发生引用更新的地方。
    + 重新进行标记，修正并发标记期间因为用户引用程序的继续运行而导致的标记。
    + 并发清除，开启用户线程，同时GC线程清除未标记的区域做清扫。
    + 对CPU敏感，无法处理悬浮垃圾，使用标记-清楚容易导致大量的碎片。

  + G1收集器，面向服务器，GC停顿的时间适当，同时具备高的吞吐量。后台维护一个优先队列，在每次收集的时候，优先选择价值最大的region。
  + ZGC收集器，采用的是标记-复制的方法，产生STW的概率小。


### 框架