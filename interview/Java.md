### 基础语法

+ 静态方法和非静态变量？

  + 静态方法是属于类的，在类被加载的时候就会被分配内存，但是非静态成员是属于实例对象的，只有在对象实例化之后才存在，需要通过类的实例化之后的对象去访问。
  + 静态方法是属于某一个类的，而不是属于某一个对象实例的。
  
+ 静态方法和实例方法

  + 在外部调用静态方法的时候，可以通过类名.静态方法或者是对象名.方法来调用，而实例方法之可以通过对象.方法来进行调用。
  + 静态方法在类里面只可以访问静态变量，而实例的方法没有这个限制。
  
+ 重载和重写的区别

  + 重载是对于同一个方法根据输入的数据的不同，进行不同的处理。
  + 重写就是当子类继承了父类的方法的时候，输入的数据一样，但是要作出有区别于父类的响应，就是要覆盖父类。重写发生在运行期，方法的重写需要准询两同两小一大的原则，两同就是函数名和参数都要相同，两小就是返回类型和抛出的错误的类型需要比父类更小，一大就是对数据的控制需要比父类更大。
  
+ ==和equal的区别

  + 如果是基本的数据类型，那么就是比较值。
  + 如果是包装类型，比较的就是内存地址。
  + equal函数的实现，默认比较的是两个对象的内存地址。当然也可以自己重写equal函数自己定义比较的标准。但是注意在我们重写equal的时候必须要重写hashcode，这样才是符合逻辑的，因为相同的对象的hash值必须要一样。不然到时候使用hashmap的时候会出现问题。

  ```java
     // 自定义比较函数
  	@Override
      public boolean equals(Object obj) {
          if (this == obj) return true;
          if (!(obj instanceof Person)) return false;
          Person person = (Person) obj;
          return person.name != name;
      }
  	// 默认equal函数
  	public boolean equals(Object obj) {
          return (this == obj);
      }
  ```

  + 当然，还有涉及到装箱和拆箱的操作。将基本数据类型包装成包装类就是装箱的操作，反过来就是拆箱的操作。对于基本的数据类型，往往有对象的包装类，如果一个是包装类，一个是基本的数据类型，他们之间比较一般是相等的，比较的是值。

  ```java
  // 默认的equal函数
  public boolean equals(Object obj) {
          if (obj instanceof Integer) {
              return value == ((Integer)obj).intValue();
          }
          return false;
   }
  
          Integer i = 10; // Integer i = Integer.valueof(10);
          int j = i; // int j = i.intvalue();
          System.out.println(i==j); // true
  ```

  + 同时，这里需要注意的是基本数据类型的局部变量存放的地方是JAVA虚拟机栈里面的局部变量表里面，基本的数据类型的成员变量存放的地方是JAVA虚拟机的堆中，其余的对象类型，基本存放的都是堆。
  + Byte，Short，Int,Long都实现了常量池技术，也就是都创建了默认的缓存，在定义一个新的对象的时候，会从常量池缓存里面取数。如果使用等号的话比较的是值。

+ 基本的数据类型和对应的包装类

  + byte，一个字节
  + short，两个字节
  + int，四个字节
  + long，八个字节
  + char，一个字节
  + float，四个字节
  + double，八个字节
  + boolean

  + 对应的包装类就是把他们的首字母大写实现即可。
  + 区别：如果不赋值的话基本的数据类型就是对应的零值，包装类就是null。
  + 基本的数据类型和包装类之间的转换涉及到一个装箱和拆箱的过程。

+ 接口和抽象类有什么共同点和区别？

  + 共同点
    + 都不能被实例化。
    + 都可以包含抽象方法
    + 都有默认的实现方法。
  + 区别
    + 接口主要是对类的行为进行约束，你实现了某一个接口就具有了对应的行为。对于抽象类，更加强调的是一种所属关系。这里我理解的是既然是抽象类，那么就说明还不能根据某些特性将其具体化，所以这些特性应该是公共的，难以区分的。接口呢？应该是代表这某一类所特有的东西。
    + 一个类只能继承一个类，但是可以实现多个接口。
    + 接口中的成员变量只能是public static final 类型，不能被修改但是必须有初始值。抽象类的成员变量默认是default，可以在子类中被重新定义，也可以被重新赋值。

+ 深拷贝，浅拷贝和引用拷贝的区别

  + 浅拷贝会在堆上面创建一个新的对象，但是如果存在引用类型的话。会直接执行这个引用对象，不会直接进行创建一个新的，所以其实底层地址还是用的是同一块。
  + 深拷贝，深拷贝会完全复制整个对象，包含这个对象的所有内部对象。也就是完完全全复制出一份新的对象出来，内存地址完全不一样。
  + 引用拷贝就是两个不同的引用指向了同一个对象。

+ String,StringBuffer和StringBuilder的区别
  + String中的对象是不变的，因为底层是采用的是final关键字来修饰字符数组来表示这个字符串。可以认为是线程安全的，StringBuffer对方法或者是调用的方法加了同步锁，所以是线程安全的，StringBuilder不是线程安全的。
  + String类型进行改变的时候，都会生成一个新的String对象，然后指针指向新的对象，StringBuffer每次是对对象本身操作，但是StringBuilder确比StringBuffer的性能更好，但是却有非线程安全的隐患。

+ 字符串常量池
  + JVM为了提升性能和减少内存消耗针对字符串专门开辟的一块区域，主要是为了避免字符串的重复创建。当我们创建一个String对象的时候，如果常量池里面有这个常量，那么我们只创建一次，否则就创建两次。

+ 泛型
  + Java的泛型是伪泛型，在java运行期间，所有的泛型信息都会被替换掉，这也就是所谓的类型擦除。
  + 泛型类。
  + 泛型接口。
  + 泛型方法。
  + 常见的使用的符号是K，V，T，？，E

+ 反射
  + 我们通过反射，可以或得任何一个类的属性和方法。同时你还可以调用这些方法。

+ 异常
  + Exception和Error都是继承了父亲类Throwable这个类。Exception值的是程序可以处理的异常，同时这个异常可以被捕获，这个异常也可以分为可处理和不可处理的异常。Error是程序无法处理的错误。不建议通过catch捕获，这种情况一般会造成线程的停止。常见的受检查的异常有IO相关的异常，这类异常会造成无法编译的错误。不受检查的异常有数组越界，算术异常，类型转换异常等等。

+ 序列化和反序列化
  + 在进行网络传输的时候，我们常常需要将我们的java对象转化为二进制数据流传输，这个就是序列化，反序列化就是将二进制的数据流转化为我们创建的java对象。

+ HashMap的底层实现
  + HashMap的底层是数组加链表来实现的，结合起来就是链表散列。在创建一个链表数组的时候，每个位置都是一个链表，如果遇到哈系冲突，那么就会把冲突的节点加到链表中，当链表的长度超过阈值的时候，就会树化，转化为一个红黑树存储，如果小于的话，就会链化，再次转化为一个链表的形式。

+ Java的类的加载的过程
  + 加载：通过类的全名得到此类的二进制的字节流。将字节流代表的静态存储结构转化为方法区的运行数据结构。在内存中生成一个代表该类的class对象，作为方法区的这些数据的访问入口。
  + 验证：验证类的文件格式，字节码，元数据和符号引用等等。
  + 准备：正式为类变量设置内存并且设置类变量的过程。
  + 解析：虚拟机将常量池里面的符号引用替换为直接引用的过程，主要针对类或者接口，字段，方法，接口方法等等。
  + 初始化：类加载的最后一步。这一步中JVM才开始真正执行类中的java程序代码。
  + 卸载：该类的Class对象被GC，需要保证该类的所有的实例对象都被GC，同时该类没有被其他任何对象引用，该类的类加载器实例被GC。