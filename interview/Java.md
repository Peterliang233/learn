### 基础语法

+ 静态方法和非静态变量？

  + 静态方法是属于类的，在类被加载的时候就会被分配内存，但是非静态成员是属于实例对象的，只有在对象实例化之后才存在，需要通过类的实例化之后的对象去访问。
  + 静态方法是属于某一个类的，而不是属于某一个对象实例的。
+ 静态方法和实例方法

  + 在外部调用静态方法的时候，可以通过类名.静态方法或者是对象名.方法来调用，而实例方法之可以通过对象.方法来进行调用。
  + 静态方法在类里面只可以访问静态变量，而实例的方法没有这个限制。
+ 重载和重写的区别

  + 重载是对于同一个方法根据输入的数据的不同，进行不同的处理。
  + 重写就是当子类继承了父类的方法的时候，输入的数据一样，但是要作出有区别于父类的响应，就是要覆盖父类。重写发生在运行期，方法的重写需要准询两同两小一大的原则，两同就是函数名和参数都要相同，两小就是返回类型和抛出的错误的类型需要比父类更小，一大就是对数据的控制需要比父类更大。
+ 基本的数据类型和对应的包装类

  + byte，一个字节
  + short，两个字节
  + int，四个字节
  + long，八个字节
  + char，一个字节
  + float，四个字节
  + double，八个字节
  + boolean

  + 对应的包装类就是把他们的首字母大写实现即可。
  + 区别：如果不赋值的话基本的数据类型就是对应的零值，包装类就是null。
  + 基本的数据类型和包装类之间的转换涉及到一个装箱和拆箱的过程。
+ 接口和抽象类有什么共同点和区别？

  + 共同点
    + 都不能被实例化
    + 都可以包含抽象方法
    + 都有默认的实现方法。
  + 区别
    + 接口主要是对类的行为进行约束，你实现了某一个接口就具有了对应的行为。对于抽象类，更加强调的是一种所属关系。
    + 一个类只能继承一个类，但是可以实现多个接口。
    + 接口中的成员变量只能是public static final 类型，不能被修改但是必须有初始值。抽象类的成员变量默认是default，可以在子类中被重新定义，也可以被重新赋值。
+ 深拷贝，浅拷贝和引用拷贝的区别

  + 浅拷贝会在堆上面创建一个新的对象，但是如果存在引用类型的话，拷贝的对象和原对象就会共用一个内存地址。
  + 深拷贝，深拷贝会完全复制整个对象，包含这个对象的所有内部对象。
  + 引用拷贝就是两个不同的引用指向了同一个对象。
+ String,StringBuffer和StringBuilder的区别
  + String中的对象是不变的，因为底层是采用的是final关键字来修饰字符数组来表示这个字符串。可以认为是线程安全的，StringBuffer对方法或者是调用的方法加了同步锁，所以是线程安全的，StringBuilder不是线程安全的。
  + String类型进行改变的时候，都会生成一个新的String对象，然后指针指向新的对象，StringBuffer每次是对对象本身操作，但是StringBuilder确比StringBuffer的性能更好，但是却有非线程安全的隐患。
+ 字符串常量池
  + JVM为了提升性能和减少内存消耗针对字符串专门开辟的一块区域，主要是为了避免字符串的重复创建。当我们创建一个String对象的时候，如果常量池里面有这个常量，那么我们只创建一次，否则就创建两次。
+ 泛型
  + Java的泛型是伪泛型，在java运行期间，所有的泛型信息都会被替换掉，这也就是所谓的类型擦除。
  + 泛型类。
  + 泛型接口。
  + 泛型方法。
  + 常见的使用的符号是K，V，T，？，E
+ 反射
  + 我们通过反射，可以或得任何一个类的属性和方法。同时你还可以调用这些方法。

+ 异常
  + Exception和Error都是继承了父亲类Throwable这个类。Exception值的是程序可以处理的异常，同时这个异常可以被捕获，这个异常也可以分为可处理和不可处理的异常。Error是程序无法处理的错误。不建议通过catch捕获，这种情况一般会造成线程的停止。常见的受检查的异常有IO相关的异常，这类异常会造成无法编译的错误。不受检查的异常有数组越界，算术异常，类型转换异常等等。
+ 序列化和反序列化
  + 在进行网络传输的时候，我们常常需要将我们的java对象转化为二进制数据流传输，这个就是序列化，反序列化就是将二进制的数据流转化为我们创建的java对象。