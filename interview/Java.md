### 基础知识

+ 静态方法和非静态变量？

  + 静态方法是属于类的，在类被加载的时候就会被分配内存，但是非静态成员是属于实例对象的，只有在对象实例化之后才存在，需要通过类的实例化之后的对象去访问。
  + 静态方法是属于某一个类的，而不是属于某一个对象实例的。
  
+ 静态方法和实例方法

  + 在外部调用静态方法的时候，可以通过类名.静态方法或者是对象名.方法来调用，而实例方法之可以通过对象.方法来进行调用。
  + 静态方法在类里面只可以访问静态变量，而实例的方法没有这个限制。
  
+ 重载和重写的区别

  + 重载是对于同一个方法根据输入的数据的不同，进行不同的处理。
  + 重写就是当子类继承了父类的方法的时候，输入的数据一样，但是要作出有区别于父类的响应，就是要覆盖父类。重写发生在运行期，方法的重写需要准询两同两小一大的原则，两同就是函数名和参数都要相同，两小就是返回类型和抛出的错误的类型需要比父类更小，一大就是对数据的控制需要比父类更大。
  
+ ==和equal的区别

  + 如果是基本的数据类型，那么就是比较值。
  + 如果是包装类型，比较的就是内存地址。
  + equal函数的实现，默认比较的是两个对象的内存地址。当然也可以自己重写equal函数自己定义比较的标准。但是注意在我们重写equal的时候必须要重写hashcode，这样才是符合逻辑的，因为相同的对象的hash值必须要一样。不然到时候使用hashmap的时候会出现问题。

  ```java
     // 自定义比较函数
  	@Override
      public boolean equals(Object obj) {
          if (this == obj) return true;
          if (!(obj instanceof Person)) return false;
          Person person = (Person) obj;
          return person.name != name;
      }
  	// 默认equal函数
  	public boolean equals(Object obj) {
          return (this == obj);
      }
  ```

  + 当然，还有涉及到装箱和拆箱的操作。将基本数据类型包装成包装类就是装箱的操作，反过来就是拆箱的操作。对于基本的数据类型，往往有对象的包装类，如果一个是包装类，一个是基本的数据类型，他们之间比较一般是相等的，比较的是值。

  ```java
  // 默认的equal函数
  public boolean equals(Object obj) {
          if (obj instanceof Integer) {
              return value == ((Integer)obj).intValue();
          }
          return false;
   }
  
          Integer i = 10; // Integer i = Integer.valueof(10);
          int j = i; // int j = i.intvalue();
          System.out.println(i==j); // true
  ```

  + 同时，这里需要注意的是基本数据类型的局部变量存放的地方是JAVA虚拟机栈里面的局部变量表里面，基本的数据类型的成员变量存放的地方是JAVA虚拟机的堆中，其余的对象类型，基本存放的都是堆。
  + Byte，Short，Int,Long都实现了常量池技术，也就是都创建了默认的缓存，在定义一个新的对象的时候，会从常量池缓存里面取数。如果使用等号的话比较的是值。

+ 基本的数据类型和对应的包装类

  + byte，一个字节
  + short，两个字节
  + int，四个字节
  + long，八个字节
  + char，一个字节
  + float，四个字节
  + double，八个字节
  + boolean

  + 对应的包装类就是把他们的首字母大写实现即可。
  + 区别：如果不赋值的话基本的数据类型就是对应的零值，包装类就是null。
  + 基本的数据类型和包装类之间的转换涉及到一个装箱和拆箱的过程。

+ 接口和抽象类有什么共同点和区别？

  + 共同点
    + 都不能被实例化。
    + 都可以包含抽象方法
    + 都有默认的实现方法。
  + 区别
    + 接口主要是对类的行为进行约束，你实现了某一个接口就具有了对应的行为。对于抽象类，更加强调的是一种所属关系。这里我理解的是既然是抽象类，那么就说明还不能根据某些特性将其具体化，所以这些特性应该是公共的，难以区分的。接口呢？应该是代表这某一类所特有的东西。
    + 一个类只能继承一个类，但是可以实现多个接口。
    + 接口中的成员变量只能是public static final 类型，不能被修改但是必须有初始值。抽象类的成员变量默认是default，可以在子类中被重新定义，也可以被重新赋值。

+ 深拷贝，浅拷贝和引用拷贝的区别

  + 浅拷贝会在堆上面创建一个新的对象，但是如果存在引用类型的话。会直接执行这个引用对象，不会直接进行创建一个新的，所以其实底层地址还是用的是同一块。
  + 深拷贝，深拷贝会完全复制整个对象，包含这个对象的所有内部对象。也就是完完全全复制出一份新的对象出来，内存地址完全不一样。
  + 引用拷贝就是两个不同的引用指向了同一个对象。

+ String,StringBuffer和StringBuilder的区别
  + String中的对象是不变的，因为底层是采用的是final关键字来修饰字符数组来表示这个字符串。可以认为是线程安全的，StringBuffer对方法或者是调用的方法加了同步锁，所以是线程安全的，StringBuilder不是线程安全的。
  + String类型进行改变的时候，都会生成一个新的String对象，然后指针指向新的对象，StringBuffer每次是对对象本身操作，但是StringBuilder确比StringBuffer的性能更好，但是却有非线程安全的隐患。

+ 字符串常量池
  + JVM为了提升性能和减少内存消耗针对字符串专门开辟的一块区域，主要是为了避免字符串的重复创建。当我们创建一个String对象的时候，如果常量池里面有这个常量，那么我们只创建一次，否则就创建两次。

+ 泛型
  + Java的泛型是伪泛型，在java运行期间，所有的泛型信息都会被替换掉，这也就是所谓的类型擦除。
  + 泛型类。
  
  ```java
  
  public class Person<T>{
      private T key;
      
      public Person(T key) {
          this.key=key;
      }
  
      public T getKey(){
          return this.key;
      }
  
      public static void main(String[] args){
          Person person = new Person<String>("name");
          System.out.println(person.getKey());
          Person person2 = new Person<Integer>(123);
          System.out.println(person2.getKey());
      }
  }
  ```
  
  + 泛型接口。
  + 泛型方法。
  + 常见的使用的符号是K，V，T，？，E
  
+ 反射
  + 我们通过反射，可以或得任何一个类的属性和方法。同时你还可以调用这些方法。
  + 反射的优点：可以使代码更加灵活，为各种框架提供了开箱即用的功能提供了便利。缺点：让我们在程序运行的时候具有分析类的作用，同时增加了安全问题，可能会无视范型参数的安全性校验，而且性能也稍微差了一点。
  + 应用
    + 在一些框架中，比如springboot/spring等，都使用了大量的代理机制。还有比如一些注解，也用到了反射的机制。
  + 获取class对象的四种方法
    + 直接`Person.class`得到
    + 通过class提供的`class.forName("类的路径")`得到
    + 通过对象实例`person.getClass()`得到
    + 通过类加载器`ClassLoader.loadClass("类的路径")`得到
  
+ 注解
  
  + Annotation是一种特殊的注释，用于修饰类，方法和变量。注解只有在被解析之后才会生效使用
    + 编译期直接扫描，编译器在编译期间就对代码进行了扫描并且进行处理，比如override。
    + 运行期间通过反射处理。就比如一些框架自带的注解同时通过在执行期间的反射来进行处理的。
  
+ 异常
  + Exception和Error都是继承了父亲类Throwable这个类。Exception值的是程序可以处理的异常，同时这个异常可以被捕获，这个异常也可以分为可处理和不可处理的异常。Error是程序无法处理的错误。不建议通过catch捕获，这种情况一般会造成线程的停止。常见的受检查的异常有IO相关的异常，这类异常会造成无法编译的错误。不受检查的异常有数组越界，算术异常，类型转换异常等等。

+ 序列化和反序列化
  + 在进行网络传输的时候，我们常常需要将我们的java对象转化为二进制数据流传输，这个就是序列化，反序列化就是将二进制的数据流转化为我们创建的java对象。
  + 序列化的作用是通过网络传输对象或者是将对象存储到文件系统，数据库或者内存中。
  + 如果不想让某一些变量序列化，可以加关键字transient，transient只能用来修饰变量，不能用来修饰方法或者是类。transient进行反序列化的时候会将变量设置为对应的默认值。static不属于任何对象，不会进行序列化操作。

+ 代理模式

  + 代理模式的主要功能是拓展目标对象的功能。比如在目标对象的某一个方法执行前后你可以自己定义一些操作。
  + 静态代理
    + 静态代理就是在编辑阶段将接口，实现类，代理类这些都变成一个一个实际的class文件。
    + 实现步骤
      + 定义一个接口及其实现类
      + 创建一个代理类实现这个接口
      + 将目标对象注入代理类中，然后在代理类的对应的方法调用目标类中对应的方法。这样的话，我们可以通过代理类屏蔽目标对象的访问，同时也可以在目标函数执行前后自定义一些函数。
  + 动态代理
    + 动态代理在运行时动态生成类字节码，并且加载到JVM里面。
    + 动态代理分为JDK 动态代理和CGLIB动态代理。JDK 动态代理只能实现一个实现了接口的类。主要的过程就是重写一个InvocationHandler函数。CGLIB动态代理是通过生成一个代理类的子类来拦截被代理类的方法调用。

+ HashMap的底层实现
  + HashMap的底层是数组加链表来实现的，结合起来就是链表散列。在创建一个链表数组的时候，每个位置都是一个链表，如果遇到哈系冲突，那么就会把冲突的节点加到链表中，当链表的长度超过阈值的时候，就会树化，转化为一个红黑树存储，如果小于的话，就会链化，再次转化为一个链表的形式。

+ Java的类的加载的过程
  + 加载：通过类的全名得到此类的二进制的字节流。将字节流代表的静态存储结构转化为方法区的运行数据结构。在内存中生成一个代表该类的class对象，作为方法区的这些数据的访问入口。
  + 验证：验证类的文件格式，字节码，元数据和符号引用等等。
  + 准备：正式为类变量设置内存并且设置类变量的过程。
  + 解析：虚拟机将常量池里面的符号引用替换为直接引用的过程，主要针对类或者接口，字段，方法，接口方法等等。
  + 初始化：类加载的最后一步。这一步中JVM才开始真正执行类中的java程序代码。
  + 卸载：该类的Class对象被GC，需要保证该类的所有的实例对象都被GC，同时该类没有被其他任何对象引用，该类的类加载器实例被GC。

+ 集合

  + java的集合是由两大接口派生而来的，一个是Collection接口。主要用来存放单一元素，还有一个map接口，用来存放键值对。Collection派生出了三个接口，分别是List，Set和Queue。
  + list
    + ArrayList是数组实现。
    + Vector是数组实现。
    + LinkList是双向链表实现。
  + Set
    + HashSet基于Hashmap实现，底层采用的是HashMap来存储元素。
    + LinkedHashSet：继承了HashSet，内部是LinkedHashMap来实现的。
    + TreeSet：内部是红黑树实现。
  + Queue
    + Priority_queue利用数组来实现了二叉堆。
    + ArrayQueue：采用的是数组+双指针实现。
  + map
    + 在JDK1.8之前，采用的是HashMap来实现的，如果遇到哈希冲突就会使用拉链法来解决冲突。JDK1.8之后，在解决哈希冲突的时候有了比较大的变化，当链表的长度超过域值的时候，链表会转化为一棵树，翻过来树会转化一个一个链表。HashMap不是线程安全的，ConcurrentHashMap是线程安全的。
  + Comparable和Comparator的区别
    + comparable接口实际上是出自java.lang包，它包含一个CompareTo方法来排序。
    + comparator接口实际上是出自java.util包，他有一个compare函数来进行排序。
  + HashMap的底层实现
    + HashMap的底层采用的是数据加链表的方法来实现的，在我们插入一个新的元素到集合里面的时候，会先通过hashCode进行哈系，然后利用扰动函数计算出是在哪个桶里面。然后如果对应的位置的hash值是一样的，那么我们就会进行覆盖，如果存在不同的hash值，那么我们就会放到这个桶里面，如果是链表的话，就会插入到链表的最后面，否则就是插入到红黑树上面，注意这里需要进行红黑树的调整，但是时间复杂度也是可以接受的。注意当单个链表的长度超过了8而且总的数组的长度超过了64的时候才会触发树化。
    + 主要的几个函数是`put`，`get`，和`resize`
    + `put`方法
      + 先计算出相关的hash值找到对应的桶的位置，如果是相等的话，那么我们就可以对这个位置的元素进行覆盖，否则就是插入到这个桶的位置。
    + `get方法`
      + 还是先得到hash值，如果桶里面只有一个元素，那么就直接返回，否则就从红黑树里面或者是链表里面返回第一个节点（first节点）。
    + `resize`方法
      + 当哈系冲突非常严重的时候，会出发一次重新的hash分配，并且会遍历hash表中的所有的元素，这是非常耗时的，所以我们需要尽量避免。主要的办法是增大数组的长度，对于新得到的哈希值，将其从原来的桶里面分到新的桶里面即可。
  + ConcurrentHashMap
    + JDK 1.7版本（Segment数组+HashEntry数组+链表实现）
    + 前面我们知道，HashMap不是线程安全的，而ConcurrentHashMap确实线程安全的。他使用的频率也是非常高的。ConcurrentHashMap的存储结构分为很多个Segment组合。而每个段又是类似于HashMap的结构，所以每个HashMap的内部可以进行单独扩容，但是这个段的数量一旦进行初始化就不能被扩容。默认的个数是16,所以也就默认最多支持16个多线程并发使用。（其实这里很好里面，我们把每个线程的作用空间进行了单独的切分，那么如果有并发的情况，每个线程之间都是互不干扰的，也就实现了并发安全）
    + `put`
      + 找到一个空的段，然后进行初始化，最后利用CSP算法检查是否有其他线程在这个过程中对这个段进行了操作，如果没有，那么执行put操作。找到空的段的过程是自旋的操作。
    + `get`
      + get操作也是先找到key存放的位置，然后遍历指定的位置找到相同key的value值，这里也会涉及到一个value值。
    + JDK 1.8 版本（Node数组+链表/红黑树实现）
      + `put`
        + 首先根据hash值确定在哪个数组桶里面，如果没有这个桶，那么就采用自旋+CAS来初始化一个桶，如果存在桶，但是桶里面只有一个节点，那么就不加锁,直接CAS插入。否则的话就利用Syncchronized锁对对应的节点进行加锁。
      + 使用的是Syncchronized锁和CAS机制来实现的

### 并发

### JVM

### 框架