+ 什么是RabbitMQ
  + 是实现了高级消息队列协议的开源消息代理软件。也就是消息队列
+ 特点
  + 可靠性，RabbitMQ使用了一些机制来保证可靠，如持久化，传输确认以及发布确认等。
  + 灵活的路由：在进入消息队列之前，通过交换器来路由消息。
  + 扩展性：多个RabbitMQ除了原生支持AMQP协议，还支持其他多种消息中间件协议。
  + 多种客户端语言。
  + 管理界面。
  + 插件机制。
+ AMQP是什么
  + RabbitMQ是AMQP协议的实现。生产者将消息发送给交换器，交换器和队列绑定。
+ AMQP协议的三层
  + Module Layer层：协议最高层，主要定义了一些客户端调用的命令，客户端可以使用这些命令实现自己的业务逻辑。
  + Session Layer层：中间层，主要负责客户端命令发送给服务器，再将服务器应该返回客户端，提供了可靠性同步机制和错误处理。
  + Transport Layer层：最底层，主要传输了二进制数据流，提供了帧的处理，信道复用，错误检测和数据表示等。
+ AMQP模型的几大组件
  + 交换器，消息代理服务器中用于吧消息路由到队列的组件
  + 队列，用来存储消息的数据结构，位于硬盘或者内存中
  + 绑定，一套规则，告知交换器消息应该将消息投递到哪个队列
+ 生产者
  + 消息投递的一方，包括消息体和标签
+ 消费者
  + 接受消息的一方，消费者连接到RabbitMQ服务器，并且订阅到队列上，消费消息的时候只消费消息体，丢弃标签。
+ Broker服务节点
  + 可以看作是RabbitMQ的一些服务节点，一般情况下一个Broker可以看作是一个RabbitMQ服务器。
+ Queue队列
  + RabbitMQ的内部对象，用于存储消息，多个消费者可以订阅同一个队列，这时队列中的消息会被平摊到多个消费者进行处理。
+ Exchange交换器
  + Exchange：生产者将消息发送到交换器，交换器将消息路由到一个或者多个队列中，当路由不通顺的时候，或将返回给生产者或者直接丢弃。
+ RoutingKey路由键
  + 生产者将消息发送给交换器的时候，会指定一个RoutingKey，用来制定这个消息的路由规则，这个RoutingKey需要和交换器的类型和绑定的键联合使用才能最终生效。
+ Binging绑定
  + 通过绑定将交换器和队列关联起来，一般会制定一个Bindingkey，这样我们的RabbitMQ就知道如何正确的路由消息到队列了。
+ 交换器的类型
  + fanout：把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。
  + direct：把消息路由到bindingkey和RoutingKey完全匹配的队列中。
  + topic：
    + 匹配规则：
    + RoutingKey为一个点号。
    + BindingKey和RoutingKey一样也是点好分隔的字符串。
    + headers：不依赖路由键匹配规则来路由消息，是根据发送消息内容中的headers属性进行匹配。
+ 生产者的消息运转流程
  + Producer先连接到一个Broker，建立连接Connection,开启一个信道Channel。
  + Producer声明一个交换器并且设置好相关属性。
  + Producer声明一个队列并且设置好相关属性。
  + Producer通过路由键将交换器和队列绑定到一起。
  + Producer发送消息到Broker，其中包含了路由键，交换器等信息。
  + 相应的交换器根据接受到的路由键查找匹配的队列。
  + 如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。
  + 关闭信道。
  + 管理连接。
+ 消费者接受消息的过程
  + Producer先连接到Broker，建立Connection，开启一个Channel。
  + 向Broker请求消费响应的队列中的消息，可能会设置响应的回调函数。
  + 等待Broker回应并且投递到相应的队列中的消息，接受消息。
  + 消费者确认收到的消息，返回ACK
  + RabbitMQ从队列里面删除已经确定的消息。
  + 关闭信道
  + 关系连接
+ 交换器无法根据自身类型和路由键找到对应的符合条件的队列，有哪些处理？
  + mandatory：true返回消息给生产者
  + mandatory：false直接丢弃
+ 死信队列
  + 当消息在一个队列中变成死信了之后，它能被重新发送到另一个交换器中，这个交换器就是DLX，绑定DLX的队列就称之为死信队列。
+ 导致死信的几种原因
  + 消息被拒
  + 消息TTL过期
  + 队列满了，无法添加
+ 延迟队列
  + 存储对应的延迟队列，指当消息被发送以后，并不想让消费者立刻拿到队列的消息，而是等待特定的时间，消费者才能拿到队列里面的消息。
+ 优先级队列
  + 优先级高的队列会先被消费，可以通过设置x-max-priority设置

+ 事物机制
  + RabbitMQ客户端中和事物机制相关的方法有三种
  + channel.txSelect用于将当前的信道设置成事物模式。
  + channel.txCommit 用于提交事物。
  + channel.txRollback用于事物的回滚，如果在事物提交执行之前由于RabbitMQ异常崩溃或者其他原因抛出一场，通过txRollback来回滚。
+ 发送确认机制
  + 生产者把信道设置为confirm确认模式，设置后，所有再改信道发布的消息会被制定一个唯一的ID，一旦消息被投递到所有的匹配的队列中的时候，RabbitMQ就会发送一个确认给生产者，这样生成者就知道消息到达了目的地了。
+ 消费者某些原因无法处理当前接受的消息如何来拒绝？
  + channel.basicNack
  + channel.basicReject
+ 消息传输如何保证层级
  + 最多一次，消息可能会丢失，但是不会重复传输。
  + 最少一次，消息不会丢失，但是可能会重复传输。
  + 恰好一次，每条消息肯定仅传输一次
+ vhost
  + 每一个RabbitMQ服务器都能创建虚拟的消息服务器，也叫做虚拟主机，简称vhost默认为/
+ 集群中的节点类型
  + 内存节点：ram，将变更写入内存中
  + 磁盘节点：disc，磁盘写入操作
  + RabbitMQ至少有一个磁盘节点
+ 队列结构
  + rabbit_amqqueueu_process：负责协议相关的消息处理，即接受生产者发布的消息，想消费者交付消息，处理消息的确认等
  + backing_queue：和i消息存储的具体形式和引擎，并向rabbit amqqueueu process提供相关的接口以供调用
+ rabbitMQ中消息的几种可能的状态
  + alpha：消息内容和消息索引都存储在内存中
  + beta：消息内容保存在磁盘中，消息索引保存在内存中
  + gamma：消息内容保存在磁盘中，消息索引在磁盘和内存中
  + delta：消息内容和索引都在磁盘中